Title: PostgreSQL CRASH COURSE - Learn PostgreSQL in 2024
Channel: Troi
Published: 2022-01-14T21:40:32Z
Duration: PT50M26S
Description: Get My FULL POSTGRES COURSE 90% OFF: https://www.udemy.com/course/practical-postgres-master-the-most-important-parts-of-sql/?couponCode=YOUTUBE-PG-BEGINNER

Thank you for watching! If you enjoyed please consider subscribing and liking the video. 

Follow me on Twitter - https://twitter.com/troy_amelotte

Tools used (for mac, pc users try pgAdmin)
Postico - https://eggerapps.at/postico/
Postgres install - https://www.postgresql.org/download/macosx/

Transcript:

[00:00:00] so you want to learn postgres huh well i
[00:00:02] know a thing or two about postgres in
[00:00:05] fact i would say that learning postgres
[00:00:07] and sql has been one of the most
[00:00:10] beneficial skills i've learned
[00:00:11] throughout my entire career not only has
[00:00:14] it been helpful on the job it's also
[00:00:16] been a really impressive skill to be
[00:00:18] able to flex in interviews with
[00:00:19] potential employers and i've landed
[00:00:22] multiple contract jobs just because i
[00:00:25] know postgres well enough to be able to
[00:00:27] do things that other developers simply
[00:00:29] can't today in this video i'm going to
[00:00:32] give you some initial skills to help you
[00:00:35] on your journey to postgres mastery
[00:00:37] we're just going to be talking about a
[00:00:38] lot of the basics perhaps in future
[00:00:40] videos we'll dive a little bit deeper
[00:00:42] and talk about some more advanced
[00:00:43] concepts but this should lay the
[00:00:45] foundation for your journey to postgres
[00:00:47] mastery
[00:00:48] so without further ado let's dive right
[00:00:51] in so the first question is what is
[00:00:54] postgres what is sql really well
[00:00:57] postgres is a relational database you're
[00:00:59] going to hear a lot about relational and
[00:01:01] non-relational databases out there and
[00:01:04] an initial assumption a lot of
[00:01:06] developers might have and in fact when i
[00:01:08] used to teach i would ask students a lot
[00:01:10] what's your assumption what do you think
[00:01:12] relational means versus non-relational
[00:01:14] and oftentimes they would say well i
[00:01:16] would just assume
[00:01:18] that a relational database allows you to
[00:01:20] relate
[00:01:21] data together and while that's true you
[00:01:23] can do that in a relational database
[00:01:26] what's also true is that you can do that
[00:01:27] in a non-relational database what it
[00:01:29] actually is talking about is the math
[00:01:31] under the hood what makes the database
[00:01:33] tick in relational databases it's
[00:01:35] leveraging relational algebra and that's
[00:01:38] the reason for the name so that's just a
[00:01:40] common uh misconception that i wanted to
[00:01:42] clear up before we do uh right into
[00:01:44] postgres
[00:01:45] so sql stands for structured query
[00:01:47] language it's a language that allows us
[00:01:50] to communicate with our database and
[00:01:52] make changes um by using a series of
[00:01:54] keywords we're gonna dive into it a
[00:01:56] little bit more but just setting the
[00:01:58] stage for for the rest of our talk today
[00:02:01] so let's go ahead and talk about the
[00:02:04] core building block for
[00:02:06] essentially all sql databases which is
[00:02:10] tables and tables are they're they're
[00:02:12] essentially containers for data they're
[00:02:14] made up of columns and rows you can
[00:02:16] think much like an excel spreadsheet or
[00:02:19] a google um sheet spreadsheet
[00:02:22] you're gonna have a series of columns
[00:02:24] and then you're gonna have multiple rows
[00:02:25] often times we'll talk about entries
[00:02:28] into a um into a table as entities so if
[00:02:31] you ever hear me talk about an entity
[00:02:33] i'm just talking about one object in the
[00:02:36] database so for example here
[00:02:38] what we
[00:02:39] what i would say is maybe this first
[00:02:41] user here he's an entity in the database
[00:02:44] and what we can see is this is actually
[00:02:47] a screenshot from the editor that will
[00:02:48] be in soon is we have a series of these
[00:02:51] columns here so we've got an id column
[00:02:53] email column name column age column and
[00:02:55] password column and what you'll also see
[00:02:58] is that we have these rows we have these
[00:03:00] entries into
[00:03:01] that table and those rows have specific
[00:03:04] uh entries for each column so for
[00:03:07] example for the email column we're going
[00:03:08] to see
[00:03:09] troy at fake email.com is this user's
[00:03:12] email address
[00:03:14] and then you know same for name same for
[00:03:16] age and password here these are actually
[00:03:18] hash you're never really going to store
[00:03:20] raw text passwords in a database that's
[00:03:22] a huge concern
[00:03:24] security concern we're not going to talk
[00:03:26] about that much
[00:03:27] in this video maybe that's a great topic
[00:03:29] for future ones but i just wanted to
[00:03:31] explain why you're seeing that nonsense
[00:03:33] in the password column
[00:03:36] okay so let's jump over to an editor now
[00:03:39] and let's create our first table
[00:03:42] together
[00:03:43] alright so welcome to post to go the
[00:03:44] postico is just an interface for
[00:03:47] interacting with postgres i'll have some
[00:03:50] links for setting up postgres on your
[00:03:51] local machine as well as postago down
[00:03:54] below in the description
[00:03:55] but all you need to know for now is it's
[00:03:57] an editor that allows us to write sql
[00:03:59] and interact with our database it also
[00:04:01] gives us a nice ui so that we can see
[00:04:03] things it's fantastic for beginners
[00:04:06] so
[00:04:07] let's jump right in
[00:04:09] so here this is where we're going to
[00:04:10] write our sql so you know we can type
[00:04:13] away as normal
[00:04:14] but um
[00:04:16] sql like i said is made up of a series
[00:04:19] of keywords so what do i say when i mean
[00:04:22] keyword well
[00:04:23] a keyword is just a word that tells sql
[00:04:26] to do a very specific operation and in
[00:04:28] this example what we want to do is tell
[00:04:31] sql or tell postgres i should say to
[00:04:33] create a table okay
[00:04:36] so what table are we creating today well
[00:04:39] i think it's best to go through anything
[00:04:41] new that we're learning with a actual
[00:04:44] realistic example so we're going to
[00:04:46] build a little bit of a schema here that
[00:04:48] would represent an application that
[00:04:50] allows us to have users and posts
[00:04:53] eventually
[00:04:55] and when i say schema all a schema is is
[00:04:57] it's just the database itself the way
[00:04:59] that data is laid out is the schema
[00:05:02] okay fantastic so let's jump into it
[00:05:05] first we're going to create a table i'm
[00:05:07] going to call the table
[00:05:09] profile for now i'm going to revisit
[00:05:11] that but we'll come back to it and then
[00:05:13] the syntax for this is after we say
[00:05:15] create table profile
[00:05:18] we open up these parentheses here and
[00:05:20] then inside of here each line we're
[00:05:22] going to define a new column for that
[00:05:25] table troy from the future here i'm
[00:05:27] sorry for the interruption i just want
[00:05:29] to note that sql statements need to end
[00:05:32] in a semicolon i didn't specifically say
[00:05:35] that which is my bad but you'll notice
[00:05:37] that every statement that i write
[00:05:39] throughout this entire video ends in a
[00:05:41] semicolon it's how we tell sql that the
[00:05:43] statement is done
[00:05:46] so we always whenever you're working
[00:05:49] with a database you need to make sure
[00:05:51] that you have an id column
[00:05:53] that column is going to be what we call
[00:05:54] a serial column
[00:05:57] and we're going to go ahead and also
[00:05:58] tell it that this is the primary key
[00:06:03] the user might also have a name
[00:06:06] the name we're going to say is varchar
[00:06:08] 255
[00:06:10] and don't worry i'm going to come back
[00:06:12] and talk through all of this what does
[00:06:13] this stuff mean you might not know but i
[00:06:15] think it's helpful to write it all out
[00:06:17] first so that you can see it together
[00:06:20] we're going to have an email that's also
[00:06:21] going to be varchar255
[00:06:23] we're going to have the password i'm
[00:06:25] going to make the password text
[00:06:29] and then finally we're going to have an
[00:06:30] age which is an integer
[00:06:33] okay great so what does all of this mean
[00:06:35] and why are there these different uh
[00:06:38] capitalizations for certain words and
[00:06:40] some not
[00:06:42] okay so first things first let's address
[00:06:45] capitalization
[00:06:46] in programming languages you're going to
[00:06:48] have a series of conventions oftentimes
[00:06:50] in languages like javascript you're
[00:06:52] going to see a lot of camel cases in
[00:06:53] python you're going to see a lot of
[00:06:55] snake casing in sql the convention is
[00:06:58] that you uppercase
[00:07:00] all keywords and anything that relates
[00:07:04] to your table itself should be lowercase
[00:07:06] snake case so all lowercase characters
[00:07:08] snake case the reason that is is sql
[00:07:12] does not care about casing
[00:07:14] so this
[00:07:17] is the same thing it's going to do the
[00:07:19] same operation me lowercasing create had
[00:07:21] no effect on it but you write code for
[00:07:25] other people and it's important to
[00:07:27] structure things in a way that makes it
[00:07:28] easy to read so here by uppercasing
[00:07:31] everything that's a keyword it becomes
[00:07:33] very very clear what is baked into
[00:07:36] postgres itself and what is something
[00:07:38] that i'm naming what is something that i
[00:07:40] have control over so here this this
[00:07:43] profile name this is a name i'm giving
[00:07:45] it could be anything i want virtually i
[00:07:48] could call this person i could call this
[00:07:52] user
[00:07:54] but for now we we may call it profile i
[00:07:56] want to come back to that user point but
[00:07:58] that's the idea is that you're
[00:07:59] uppercasing all of the keywords and
[00:08:02] anything that is lowercase is something
[00:08:04] you're naming yourself
[00:08:06] so let's follow that to the next line
[00:08:09] and in fact i'm going to skip over id
[00:08:10] for a second because it's the most
[00:08:12] complex column we have we're going to
[00:08:13] talk about name next
[00:08:15] so name here that's well the name of the
[00:08:18] column i'm creating a column and i'm
[00:08:19] calling it name and this is something to
[00:08:21] look out for the entirety of this video
[00:08:24] is anytime you see something that's
[00:08:26] lowercase you should assume that it's
[00:08:28] something that i'm naming it's not
[00:08:30] something that's built into postgres
[00:08:32] itself
[00:08:33] next we have this which is a data type
[00:08:37] the data type is what constraints we're
[00:08:40] placing on this column itself and for me
[00:08:44] this is what makes using relational
[00:08:46] databases so powerful you can add
[00:08:48] constraints to your columns data does
[00:08:51] not just exist in containers that have
[00:08:53] rules that are made up they are enforced
[00:08:56] by the database itself i could not
[00:08:59] insert just a raw number into the name
[00:09:01] column if i wanted to and the reason is
[00:09:04] i'm telling postgres here that this
[00:09:06] column is varchar255 what is varchar
[00:09:10] that's a great question you might ask
[00:09:12] this is the syntax for a comment so i'm
[00:09:14] just you know i can write anything in
[00:09:15] here it doesn't matter the editor
[00:09:17] ignores it i'm just commenting on
[00:09:20] the column and it's good for taking
[00:09:21] notes so what i'm going to say here is
[00:09:23] varchar
[00:09:25] and i'll uppercase it
[00:09:28] is a text column
[00:09:30] that has
[00:09:31] a constraint
[00:09:33] on size okay and i know it's it's
[00:09:36] overflowing a little bit to the next
[00:09:38] line but this is the same line so the
[00:09:40] idea here is that varchar is a text
[00:09:42] based column but critically it has a
[00:09:45] constraint on how long that text can be
[00:09:49] and the upper bounds for that is 255
[00:09:52] characters right so
[00:09:54] the max we can do is varchar255 but
[00:09:56] varchar 50 is valid as well and i think
[00:09:59] it's probably fine for name right it's
[00:10:01] pretty rare to have a name that's
[00:10:02] greater than 50 characters maybe for
[00:10:04] covering all of our bases we'll do a 100
[00:10:07] character name column so what this means
[00:10:10] is that this column is only going to
[00:10:12] take up enough space to show 100
[00:10:14] characters and it's a great way to
[00:10:16] optimize your database so that you're
[00:10:17] not consuming more data than you need
[00:10:20] so here again we're saying that this
[00:10:22] name column is a text column and it can
[00:10:24] only max out at 100 characters
[00:10:27] for email it's the same thing i'll leave
[00:10:29] 255 you can have some long emails we'll
[00:10:31] leave 255 and then password is just
[00:10:34] plain text and the reason you would do
[00:10:35] that
[00:10:36] is that at least
[00:10:39] for applications i've worked on in
[00:10:41] pretty much any app that you're ever
[00:10:42] going to touch actually
[00:10:44] you're going to be hashing passwords in
[00:10:46] the database and password hashes can get
[00:10:48] pretty long depending on
[00:10:50] what hashing um uh library you're using
[00:10:54] and what um
[00:10:56] hashing algorithm you're using you know
[00:10:57] whether you're using
[00:10:58] sha or or md5 anyways that's not
[00:11:02] important for this talk the point is i'm
[00:11:04] making password text because placing
[00:11:06] constraints on something that's going to
[00:11:07] be hashed it's kind of silly next up we
[00:11:10] have age which is an integer
[00:11:12] an integer um is you know well it's
[00:11:16] straightforward it's a number itself so
[00:11:18] you're gonna see
[00:11:20] you know uh numbers in here like 20 etc
[00:11:24] um i want to note that there's a lot of
[00:11:26] different types for your columns and if
[00:11:29] you want an exhausted list of them you
[00:11:32] can google postgres column types and
[00:11:34] you'll get an extremely large list of
[00:11:36] all the different types
[00:11:39] one of those such types is serial okay
[00:11:41] cereal is a special type because it sets
[00:11:43] up some additional stuff for us some
[00:11:45] additional stuff that i'll dive into
[00:11:47] more in a future advanced postgres
[00:11:49] tutorial but for now the way i want you
[00:11:52] to think of this column is this column
[00:11:53] is an integer that automatically
[00:11:58] automatically adds one for us
[00:12:02] every new entity so every single time we
[00:12:05] insert into this table it will
[00:12:07] automatically add one to the id call and
[00:12:10] what i mean by that is our first profile
[00:12:13] that we insert
[00:12:14] the idea will be one it starts at one
[00:12:16] with a serial column then the next one
[00:12:18] we don't have to do anything it'll just
[00:12:21] automatically
[00:12:22] get the id of two
[00:12:24] the id column is something you never
[00:12:26] want to edit yourself you want to let
[00:12:28] the database handle this when you're
[00:12:30] inserting profiles later and we'll talk
[00:12:32] about this a bit more when we're
[00:12:33] actually inserting data momentarily but
[00:12:36] we want to avoid touching this column
[00:12:39] this column is something we want the
[00:12:40] database to control
[00:12:42] the next part is the primary key
[00:12:45] so primary key is just telling the
[00:12:47] database that this is the key that we're
[00:12:49] using to represent each row in the table
[00:12:52] and critically um that also means that
[00:12:55] it's going to be unique right we
[00:12:56] shouldn't have multiple profiles that
[00:12:58] have the same id it's a unique
[00:13:00] identifier that we can then use later on
[00:13:03] to reference for specific rows it's
[00:13:06] incredibly useful and we'll show that
[00:13:08] more as we get later into the crash
[00:13:11] course
[00:13:12] so again serial is a data type it's an
[00:13:14] integer that automatically does plus one
[00:13:16] every time
[00:13:18] so without further ado let's go ahead
[00:13:20] and execute this statement
[00:13:23] so it worked that's what this create
[00:13:25] table is and i can show you it worked
[00:13:26] because
[00:13:27] postago is awesome and if we come back
[00:13:29] here to the lecture db and we hit this
[00:13:31] refresh icon at the top you'll notice
[00:13:33] that there's this profile table here and
[00:13:35] if we click into it we're seeing id name
[00:13:37] email password and age sorry if that's a
[00:13:39] bit small i tried to increase the font
[00:13:41] up there but but i couldn't
[00:13:43] but that's our table it's there it does
[00:13:45] exist
[00:13:47] but you might be saying troy
[00:13:50] in
[00:13:51] it seems kind of weird to call it a
[00:13:53] profile this seems like this table
[00:13:55] should probably be called user
[00:13:58] well
[00:14:00] if we run this it's gonna fail and we're
[00:14:02] getting syntax error at or near
[00:14:05] user that's a bit strange
[00:14:07] think for a minute why that might happen
[00:14:09] and you might get a bit hint a bit of a
[00:14:12] hint by the coloring here so pause the
[00:14:15] video if you want a second to just think
[00:14:16] about why that could happen
[00:14:19] all right here's why
[00:14:21] this is a keyword so creating a table
[00:14:24] that's called table
[00:14:26] wouldn't work because like i said at the
[00:14:28] start
[00:14:30] sql doesn't care about casing so when it
[00:14:33] sees this lowercase table it's treating
[00:14:35] it the same as the uppercase one and it
[00:14:37] thinks that it's a keyword right so it's
[00:14:39] seeing some syntax error it's like hey
[00:14:40] you're using a keyword here we're
[00:14:42] expecting a name there's an easy way to
[00:14:44] admit this
[00:14:46] whenever you're trying to name something
[00:14:48] in sql or reference something that is
[00:14:50] not a keyword but happens to share the
[00:14:52] same name as one you can wrap it in very
[00:14:55] specifically double quotes so we can say
[00:14:58] user now
[00:15:00] this works and we get a user table
[00:15:03] so if we refresh we'll see
[00:15:05] the user table
[00:15:07] one last note on tables before we move
[00:15:09] on
[00:15:10] you'll notice i'm calling it the user
[00:15:12] table not users
[00:15:15] the reason for this
[00:15:17] is that the convention that you'll often
[00:15:19] see in postgres is that you name tables
[00:15:22] as singular items and the thought behind
[00:15:24] that is that you think about tables as
[00:15:27] this bag that you put things in and
[00:15:29] because of that when you're talking
[00:15:31] about it it's really useful to think of
[00:15:33] it as a user table right it's a bag to
[00:15:35] contain things so you wouldn't say you
[00:15:37] have a you would say you have a bag of
[00:15:39] candy not you have bags of candy right
[00:15:42] unless you have multiple
[00:15:43] so that's the thought process and i've
[00:15:46] seen it broken i've worked at companies
[00:15:48] before that pluralized tables it doesn't
[00:15:51] really matter right it's not going to
[00:15:52] make a big difference on your software
[00:15:55] itself but there are times when you'll
[00:15:57] have tools that automatically generate
[00:16:00] things for you based off of your table
[00:16:02] names rails and ruby are a great example
[00:16:05] of that
[00:16:05] rails will automatically generate a lot
[00:16:07] of code for you as long as you follow
[00:16:09] good conventions and the other thing is
[00:16:11] it's a convention it's what other
[00:16:13] developers will be expecting from your
[00:16:15] work so i think it's important to keep
[00:16:17] them singular whenever possible and if
[00:16:20] you ever work with or for me
[00:16:23] you know and i see a a pluralized table
[00:16:26] in your code i'm going to come at you a
[00:16:27] little bit you're going to have to be
[00:16:28] prepared uh for me to shoot down your
[00:16:31] code review and tell you you need to go
[00:16:33] change that
[00:16:35] okay great so we've got our user and
[00:16:37] profile in place we're going to go ahead
[00:16:39] and drop the profile table this is
[00:16:41] really really easy
[00:16:42] and post secure you can just right click
[00:16:44] and delete
[00:16:46] and delete
[00:16:48] and it's gone uh in order to do that in
[00:16:51] sql you can just say drop table and then
[00:16:53] the table name
[00:16:54] but we have an editor i would recommend
[00:16:56] using an editor especially as you're
[00:16:57] getting started with sql and i think
[00:17:00] post-aco is a great option okay we've
[00:17:03] got our table in place we're very
[00:17:05] excited about that
[00:17:07] now we just need to get data inside
[00:17:09] we're going to learn some new ones here
[00:17:11] we're going to say insert
[00:17:13] into our table name which is user and
[00:17:16] remember
[00:17:17] user here happens to also be a keyword
[00:17:19] so we're going to wrap it in double
[00:17:21] quotes
[00:17:22] then in parentheses we specify what
[00:17:25] columns we want to insert well those
[00:17:28] columns are email
[00:17:30] name
[00:17:31] age and password
[00:17:33] you might be asking yourself or thinking
[00:17:35] why why isn't id here we surely want an
[00:17:38] id for each user
[00:17:41] well if you remember back
[00:17:43] to when we were talking about creating a
[00:17:45] table the id is of data type serial what
[00:17:49] that means is it's going to
[00:17:50] automatically generate
[00:17:52] an integer id for us every new row so we
[00:17:55] don't have to insert it ourself in fact
[00:17:57] it would be a mistake to
[00:17:59] this user that we insert will
[00:18:00] automatically have the id of one for us
[00:18:03] because of postgres's serial data type
[00:18:07] let's go ahead and
[00:18:09] move on with the query so we've got
[00:18:10] insert into user the columns we're
[00:18:12] inserting email name age and password
[00:18:14] and then we say the values which is a
[00:18:17] keyword
[00:18:18] and now we can start to enter those
[00:18:20] values and how this works
[00:18:23] is
[00:18:24] within these parentheses we go in the
[00:18:26] same order that the columns are listed
[00:18:28] in these so the order here doesn't
[00:18:30] matter we can order this however we want
[00:18:32] we just need to make sure we follow the
[00:18:35] order
[00:18:36] after the values keyword so within here
[00:18:38] so what that means is email needs to
[00:18:40] come first here when we're entering the
[00:18:41] value name second age third and password
[00:18:44] fourth
[00:18:45] so for email i'm going to go ahead and
[00:18:47] enter
[00:18:48] troy
[00:18:49] at fake.email
[00:18:52] for name i'm going to enter troy
[00:18:55] for age 126
[00:18:57] and for password i'll enter some
[00:19:00] nonsense
[00:19:03] okay this is great we've got our values
[00:19:05] in place and if we run this it should
[00:19:07] work but you might have a question what
[00:19:10] are these single quotes doing here well
[00:19:13] single quotes are how we tell sql that
[00:19:16] we're entering some text so
[00:19:18] this is just looked at by sql as text
[00:19:22] it's not read as if it was part of the
[00:19:24] code itself so if we put some sql in
[00:19:27] here
[00:19:29] this would get inserted as the actual
[00:19:31] email or sorry let me use something
[00:19:33] you're familiar with we haven't gotten
[00:19:34] to create statement or to select
[00:19:36] statements yet i'm getting ahead of
[00:19:37] myself
[00:19:38] if we put like create table in here this
[00:19:40] will get inserted as the email right
[00:19:43] it's not gonna look at this as code it
[00:19:45] looks at it as text and in fact without
[00:19:48] it it will look at it as code so if i
[00:19:51] omit
[00:19:52] those single quotes it will read this
[00:19:55] and we'll get a syntax error because it
[00:19:56] doesn't know what troy at fake.email is
[00:20:00] we need the single quotes to tell it
[00:20:01] that this is a string value it's also
[00:20:04] important to call out if you've done
[00:20:06] other programming languages before which
[00:20:08] if you're looking at this course you
[00:20:09] probably have
[00:20:11] single quotes and double quotes are not
[00:20:13] the same here which they are in a lot of
[00:20:15] programming languages like javascript
[00:20:17] for example and uh double quotes here
[00:20:20] are specifically for referencing columns
[00:20:24] and tables uh and whenever you use them
[00:20:27] sql will expect you to be referencing
[00:20:29] one as such and the same with single
[00:20:31] quotes if we
[00:20:32] swap these two and it's double quotes
[00:20:33] here and single quotes here we're gonna
[00:20:35] get a syntax error it's important to
[00:20:36] recognize the difference between those
[00:20:38] two
[00:20:40] ages and integer integers are not text
[00:20:43] based data they're not a string so we
[00:20:45] can just put it you know
[00:20:47] in line here we don't need to wrap it in
[00:20:49] anything okay fantastic let's execute
[00:20:53] that statement
[00:20:54] we say we've inserted and if we come
[00:20:56] back and look at our table here and
[00:20:58] refresh
[00:20:59] you will notice and i know it's a bit
[00:21:00] hard to see i'm sorry about that but the
[00:21:02] table's there and all of our information
[00:21:05] is in there correctly
[00:21:06] this is great i'm really really happy
[00:21:09] that that worked and in fact let's go
[00:21:11] ahead and insert another user
[00:21:13] just for practice sake okay i'm gonna
[00:21:15] insert another user we're gonna make it
[00:21:18] chris
[00:21:19] at another.example
[00:21:23] the person's name is gonna be you're
[00:21:24] never gonna believe it that's chris
[00:21:26] he's a notorious 98 year old man who's
[00:21:30] using her application
[00:21:31] and his password is wow i love sql 28
[00:21:38] and we'll go ahead and insert chris
[00:21:40] it does work and we can come back and
[00:21:42] look at our user table and sure enough
[00:21:45] he's along with troy now
[00:21:47] all right that's great news we've got
[00:21:49] two rows in there
[00:21:50] now
[00:21:52] you might be thinking about something
[00:21:54] and i hope you are
[00:21:56] what do you do
[00:21:58] if you don't have a nice editor like
[00:22:00] this how do you get information out and
[00:22:02] in fact what is this editor maybe doing
[00:22:05] under the hood
[00:22:06] to show us this data
[00:22:08] well
[00:22:09] friends that's what we're going to talk
[00:22:10] about next and it leads us to some more
[00:22:14] keywords the next keyword that we unlock
[00:22:17] in our journey to sql mastery is going
[00:22:19] to be select select is a keyword that
[00:22:22] allows us to
[00:22:24] fetch information from existing tables
[00:22:27] it's what postico is using under the
[00:22:30] hood to show us our entries when we go
[00:22:33] and we click on the user table here this
[00:22:35] is how it's grabbing information and
[00:22:37] remember you're not always going to have
[00:22:39] access to a nice editor like this and
[00:22:42] also select gives us additional tools
[00:22:45] that make it even better sometimes than
[00:22:48] just viewing the data in an editor and
[00:22:50] we'll show you that more
[00:22:52] later on in the video but let's cover
[00:22:53] the basics for now
[00:22:55] which of course starts with the select
[00:22:57] keyword so i'm going to go ahead and
[00:22:59] write out a basic select statement and
[00:23:01] then we'll break it down
[00:23:08] all right fantastic
[00:23:09] select star from user and let's run it
[00:23:13] and we can see here in the bottom this
[00:23:14] is our you know sql output
[00:23:17] that those rows show up in the user
[00:23:20] table the user table is there now i want
[00:23:22] you to think for a moment
[00:23:24] what does this star
[00:23:26] probably mean you can probably easily
[00:23:28] infer what from means
[00:23:30] select is clearly a keyword that's
[00:23:32] initiating the statement
[00:23:34] what do you think this star means pause
[00:23:36] the video here and contemplate with
[00:23:38] yourself
[00:23:40] so when i taught most students would
[00:23:42] assume that it meant
[00:23:44] all rows
[00:23:45] it doesn't it means all columns so this
[00:23:49] star is referring to what columns you
[00:23:52] want from user and star means all
[00:23:55] i can say i just want the name and when
[00:23:58] we run this we're only going to see troy
[00:24:00] and chris here it's only giving me the
[00:24:02] name back i can say i just want the
[00:24:04] email and it's only going to give me the
[00:24:05] email or i can do some combination give
[00:24:08] me the id the email
[00:24:10] and the name
[00:24:13] and there you go
[00:24:16] fantastic that brings up a question
[00:24:18] we'll go back to select star so we can
[00:24:20] see everything
[00:24:22] how do we say that we only want specific
[00:24:24] entries and it's a good question
[00:24:27] the way we do this
[00:24:28] is with the where keyword we can select
[00:24:32] say select all columns from the user
[00:24:34] table where and then some condition
[00:24:38] so my condition might be where the name
[00:24:41] is
[00:24:44] troy and if we run this
[00:24:47] we're only going to see that single troy
[00:24:50] uh row
[00:24:52] we can do this with any combination of
[00:24:55] different conditions so i could also say
[00:24:57] maybe get me all the users where the age
[00:25:00] is greater than 20.
[00:25:02] we'll see both of our users in that case
[00:25:04] but if we change this to 27
[00:25:07] we're only going to see chris
[00:25:09] there's a lot of different conditions
[00:25:11] that you can use with a where statement
[00:25:13] i would encourage you to look up a more
[00:25:15] exhaustive list than i'm able to go
[00:25:17] through here but it's extremely powerful
[00:25:20] and it's our way
[00:25:22] where we can specify specifically what
[00:25:24] rows we want to see and then later on
[00:25:27] when we're talking about update and
[00:25:29] delete statements where statements
[00:25:30] become critical because it allows us to
[00:25:32] specify what rows we want to um
[00:25:35] uh specifically affect from our queries
[00:25:39] all right so we've got data in we're
[00:25:42] able to select it we're able to say you
[00:25:44] know give me the user with the id of one
[00:25:46] give me the user with the id of two
[00:25:48] we have that power now the next thing we
[00:25:50] need to learn is how do we change data
[00:25:53] we've got these users in place what
[00:25:55] happens
[00:25:56] when we made a mistake troy is not 26
[00:25:59] he's 30. and we need to update that user
[00:26:01] how do we do that all right so we've
[00:26:03] just unlocked our ability to select
[00:26:06] information
[00:26:07] now we need to be able to change it so
[00:26:10] like i mentioned we want to be able to
[00:26:13] change this row from age 26 to age 30.
[00:26:17] how do we do that well in order to do it
[00:26:20] we're yet again going to need some new
[00:26:21] keywords
[00:26:23] those keywords are update
[00:26:25] and set
[00:26:26] so the way we construct an update
[00:26:28] statement is we initiate it off with the
[00:26:31] update keyword
[00:26:33] and then we tell it what table we're
[00:26:34] going to be updating in our case that's
[00:26:36] the user table
[00:26:38] then we say what we would like to change
[00:26:39] i'm going to say set
[00:26:41] the age
[00:26:42] equal
[00:26:43] to 30
[00:26:45] okay so we're saying update user set age
[00:26:48] equal to 30
[00:26:50] where
[00:26:51] and then we use that where statement
[00:26:52] again remember it from select this is
[00:26:54] how we uh drill down into it without
[00:26:58] this if i was to just say set age to 30
[00:27:00] it would update every user anytime
[00:27:03] you're writing an update statement and
[00:27:04] then later on i'll reiterate for deletes
[00:27:06] we need to make sure that we're
[00:27:08] specifying a condition or we're going to
[00:27:11] make that update to everything it's a
[00:27:13] really really good way to have some
[00:27:15] embarrassing conversations in your first
[00:27:17] engineering job
[00:27:19] so let's make sure we're using our where
[00:27:21] condition we'll say where the id
[00:27:24] is one okay so this is our condition
[00:27:26] we're saying
[00:27:27] uh update the user table set the h to
[00:27:30] b30 where the id is currently one
[00:27:33] and then the update went through let's
[00:27:35] use our new skill and let's select
[00:27:39] star from user
[00:27:41] where id is one
[00:27:43] okay and again we have to wrap this in
[00:27:46] double quotes
[00:27:48] okay and then we'll go ahead and we'll
[00:27:50] remove this statement for now we'll come
[00:27:52] back and revisit it but let's just see
[00:27:54] if we've got the update going through
[00:27:55] and we did his age is now 30. that's
[00:27:58] awesome it worked
[00:28:00] all right great
[00:28:02] so that's the basics for update
[00:28:05] statements i want to make one additional
[00:28:07] note and it's about this equal operator
[00:28:10] the equal operator as well as a lot of
[00:28:12] operators in sql
[00:28:14] they change based off of the context in
[00:28:16] which you use them
[00:28:17] this one here is being used to construct
[00:28:19] a condition because it's prefaced by a
[00:28:21] where statement this one here is being
[00:28:23] used to assign a value and that's
[00:28:25] because it's prefaced by a set it's
[00:28:27] important to distinct or to
[00:28:29] separate those two in your mind and
[00:28:31] remember that the equal sign operator
[00:28:34] changes based off of the context in
[00:28:36] which it's being used
[00:28:38] okay great that's the basics of update
[00:28:39] statements we could use this to update
[00:28:42] any of the columns really but again we
[00:28:44] want to avoid updating
[00:28:45] the id but maybe just for a sake of
[00:28:48] another example maybe we go ahead and we
[00:28:50] update the email of that same user to be
[00:28:55] uh troy
[00:28:56] test dot fake
[00:28:58] and these are obviously fake emails but
[00:29:00] let me go ahead and update that and then
[00:29:03] you know select
[00:29:05] maybe i just want to see the email from
[00:29:08] user
[00:29:09] where
[00:29:11] id is one
[00:29:14] and there you go the email has been
[00:29:16] updated that's fantastic so we've
[00:29:19] learned how to do almost all of the
[00:29:21] basic operations there's just one more
[00:29:23] left and that's removing information
[00:29:25] what happens when we have a user that we
[00:29:27] want to delete right this is an
[00:29:29] applications database we might want to
[00:29:32] remove users allow them to delete their
[00:29:34] account entirely how would we do that in
[00:29:36] sql
[00:29:38] well the way we do that is with delete
[00:29:40] statements and they start with a new
[00:29:42] keyword we say delete and we say what
[00:29:45] table it's from
[00:29:46] we'll specify user and then another
[00:29:48] callout here don't run this query the
[00:29:51] whole table is gone if we run this query
[00:29:53] we need a where condition just like
[00:29:56] we needed with the update query
[00:29:59] we're going to delete from user where
[00:30:01] the id equals to maybe our 98 year old
[00:30:04] friend chris
[00:30:05] is done using the application we gotta
[00:30:07] get rid of them so we'll go ahead and
[00:30:09] delete them again don't run just delete
[00:30:12] from user in isolation make sure you're
[00:30:14] specifying the condition so it knows
[00:30:16] what to delete
[00:30:19] so we've gone ahead and deleted that
[00:30:20] user and if we go and we select all from
[00:30:24] user so we'll get all the users
[00:30:28] we're going to see sure enough there's
[00:30:30] only one user left and that's troy
[00:30:33] all right
[00:30:34] that's the basic operations with that
[00:30:36] you can do full crud create read update
[00:30:39] delete uh operations on any table of
[00:30:42] your choosing
[00:30:43] that's the basics the building blocks of
[00:30:45] sql but now we need to talk about
[00:30:47] something just a shred more advanced
[00:30:50] and that's that data does not live alone
[00:30:54] data is related to one another
[00:30:56] right you don't just have users in your
[00:30:58] application and for our application
[00:31:00] we're going to also have
[00:31:01] posts
[00:31:02] let's talk about how to relate
[00:31:04] information together in sql
[00:31:07] i've brought you back to everyone's
[00:31:08] favorite realm it's the powerpoint realm
[00:31:10] and we're going to talk about table
[00:31:12] relationships so tables can have
[00:31:15] relationships with other tables and i'm
[00:31:18] not talking about the bachelor type i'm
[00:31:20] talking about data relating to another
[00:31:23] piece of data so
[00:31:26] information in our applications does not
[00:31:29] live alone things have relationships
[00:31:31] with one another if you think about the
[00:31:32] site you're on right now youtube each of
[00:31:35] these videos have comments how does that
[00:31:38] relationship work how do we relate those
[00:31:40] things together
[00:31:41] well the way we relate those together is
[00:31:44] through foreign keys and those foreign
[00:31:47] keys allow us to reference specific
[00:31:50] entities in another table from
[00:31:53] a table so
[00:31:55] i'll show you exactly what i mean with
[00:31:56] one of these examples here let's go
[00:31:58] ahead and look at our user post example
[00:32:01] ah that one is actually a bit covered up
[00:32:03] by me okay let's look at the avadart uh
[00:32:05] example here
[00:32:06] so the user table here and this is
[00:32:09] just real quick i want to touch on what
[00:32:10] this is this is what we would call an
[00:32:12] entity relationship diagram so it's
[00:32:14] showcasing from a high level what how
[00:32:17] our tables are laid out and related
[00:32:20] so here we have that user table that we
[00:32:22] made but you'll notice we've added
[00:32:23] something new
[00:32:25] it's the avatar id
[00:32:27] that avatar id is referencing a row an
[00:32:30] entity
[00:32:31] in the avatar table it's a new table
[00:32:35] and then the avatar itself has a user id
[00:32:38] that's referencing back to this user's
[00:32:40] id so it's related
[00:32:42] in that manner
[00:32:43] basically what that means is that each
[00:32:46] new user might have an avatar id so say
[00:32:49] we have that user one it's troy we all
[00:32:51] know and love them he's got the avatar
[00:32:53] id3
[00:32:55] what that tells sql is that if you go
[00:32:57] over to that avatar table and you look
[00:33:00] for the avatar where the id is equal to
[00:33:03] three you will find
[00:33:05] troy's avatar
[00:33:07] that kind of relationship where a user
[00:33:10] has one avatar and each avatar belongs
[00:33:13] to one user that's called a one-to-one
[00:33:16] relationship
[00:33:17] there's three different relationship
[00:33:19] types when we're using relational
[00:33:21] databases there's a one-to-one like this
[00:33:23] user and avatar relationship where one
[00:33:25] user has one avatar and one avatar
[00:33:28] belongs to one user
[00:33:30] then there's one to many and this is the
[00:33:32] most common type and it's the example
[00:33:34] we'll be using in our code
[00:33:36] one-to-many is when one entity has
[00:33:39] multiple of another entity a great
[00:33:42] example is users and posts another good
[00:33:45] example is the youtube video we have and
[00:33:48] comments a youtube video has multiple
[00:33:51] comments so you might imagine that in
[00:33:53] youtube's internal system
[00:33:55] they have a video table
[00:33:58] and then that video table um you know
[00:34:00] exists with no foreign key and then
[00:34:02] there's this other separate comments
[00:34:05] table that has video ids on each one
[00:34:08] we'll break those down more in further
[00:34:11] slides let's jump in and talk about each
[00:34:14] one of the three relationship types in
[00:34:16] depth
[00:34:17] the final ones many to many will get
[00:34:18] there we'll get there i know it's on the
[00:34:19] bullet point i don't want to make anyone
[00:34:20] nervous i just don't have a photo for it
[00:34:23] let's talk about one to one
[00:34:25] one to one is the easiest type of
[00:34:27] relationship to wrap your head around a
[00:34:29] user here has an avatar id an avatar has
[00:34:32] a user id so each row in the user table
[00:34:35] will have an id referencing a very
[00:34:38] specific entity in the avatar table we
[00:34:41] talked about this on the last slide but
[00:34:43] let's reiterate again say you have troy
[00:34:45] he's got the id of one we all know and
[00:34:47] love we made him ourself
[00:34:49] he's now got an avatar id that avatar id
[00:34:53] references the row in the avatar table
[00:34:56] in which you will find troy's avatar so
[00:35:00] if troy has the avatar id3 we would go
[00:35:03] to the avatar table and look for you
[00:35:06] know maybe you write a select statement
[00:35:08] select for the avatar where the avatar
[00:35:11] id is three and then you'll see
[00:35:14] troy's avatar is sitting there and just
[00:35:16] the same in reverse that's the critical
[00:35:18] part here is that the avatar also has
[00:35:20] the user id right that user id is
[00:35:22] referencing back to troy that's what
[00:35:25] makes it a one-to-one i want to note
[00:35:27] that although this
[00:35:29] example is one of the easiest to go
[00:35:31] through one-to-one relationships are an
[00:35:32] easy thing to wrap your head around
[00:35:34] they're actually the least useful and
[00:35:36] it's something you won't see a ton
[00:35:38] oftentimes they're used to just avoid
[00:35:40] column bloat which is when a table gets
[00:35:42] out of hand because over time you're
[00:35:44] continuously adding more and more things
[00:35:46] to an application so oftentimes you'll
[00:35:48] see it to just avoid bloating the size
[00:35:50] of your tables by spreading out
[00:35:52] information across multiple
[00:35:55] the next type of relationship is a one
[00:35:58] to many one-to-many relationships are
[00:36:00] the most common one you're going to see
[00:36:02] and in fact the next relationship we
[00:36:04] look like we look at which is a mini
[00:36:06] domini is just actually two one
[00:36:08] diminished but let's we're getting ahead
[00:36:10] of ourselves let's talk about
[00:36:11] one-to-many so one-to-many is when one
[00:36:14] entity has many of another entities or
[00:36:17] they can potentially have many of
[00:36:19] another entities and let's talk about
[00:36:21] that example a bit more in the context
[00:36:23] of youtube in this video this video has
[00:36:26] multiple comments right but it doesn't
[00:36:28] need to have multiple comments in fact
[00:36:30] when you're watching this right now it
[00:36:32] might not have any comments and that's
[00:36:34] the case
[00:36:35] you could be the first one please
[00:36:37] but anyways the point is
[00:36:39] the entity which is the video in
[00:36:41] youtube's case has the potential to have
[00:36:44] multiple comments even if it doesn't yet
[00:36:47] and the way that we set that up is
[00:36:48] through a one-to-many relationship
[00:36:50] let's jump back to thinking about our
[00:36:52] specific example which is a user and a
[00:36:54] post a user has multiple posts and the
[00:36:57] way we set that up is we keep our user
[00:37:00] table as is you'll notice it's the same
[00:37:02] it's unchanged
[00:37:04] but now we've created this post table
[00:37:07] and the post table has the user id in a
[00:37:10] one-to-many relationship it's up to the
[00:37:12] mini to say who owns it right each
[00:37:16] entity of that post will tell us who
[00:37:19] owns that user and the reason is we
[00:37:22] can't put a post id on a user because
[00:37:25] that would mean that each user can only
[00:37:27] have
[00:37:28] one post which isn't the case the user
[00:37:31] cannot reference posts the post needs to
[00:37:34] reference the user when we dive into
[00:37:37] actually making this post table i'll
[00:37:39] reiterate that and elaborate just a hair
[00:37:42] more to make sure you wrap your head
[00:37:43] around it but in relationships the mini
[00:37:47] references the one not the other way
[00:37:50] around and again the reason is that
[00:37:52] would constrain the user to only being
[00:37:55] able to have one thing right because if
[00:37:57] you think about it each of these posts
[00:37:59] has a user id
[00:38:00] that user id
[00:38:02] can only exist once per post so the post
[00:38:04] belongs to the user if we invert that
[00:38:07] and the user has a post id
[00:38:10] that would mean the user could only have
[00:38:12] one post just like they can only have
[00:38:14] one name
[00:38:15] but they don't they don't have a post id
[00:38:17] here and that
[00:38:19] uh that omitting of that column
[00:38:22] allows the user to have multiple posts
[00:38:25] through this post table
[00:38:27] let's talk about the final relationship
[00:38:29] which is a mini to mini this one is a
[00:38:32] bit more complex and in complicated
[00:38:34] schemas you'll see it a lot but don't
[00:38:36] freak out don't freak out that we have
[00:38:38] three tables now all we want to focus on
[00:38:41] here is that if you look at these tables
[00:38:42] in isolation they're actually just two
[00:38:45] one-diminis which you're comfortable
[00:38:47] with so all a
[00:38:49] mini to mini is is it relates two
[00:38:51] separate tables
[00:38:53] to each other through one center table
[00:38:55] and we typically call that table a join
[00:38:58] table so we've got a one-to-many over
[00:39:00] here and another one-to-many over here
[00:39:02] those are related together through a
[00:39:04] join table
[00:39:06] the best example i could think of for
[00:39:07] this was a school setup so you have in a
[00:39:12] school
[00:39:13] students or users that are taking
[00:39:15] classes from instructors an instructor
[00:39:18] has multiple students and a student will
[00:39:21] have multiple instructors so how do we
[00:39:22] relate that stuff together well we
[00:39:24] relate them together through the class
[00:39:27] right so we have a user a user has a
[00:39:30] class here this class as such has the
[00:39:33] user id remember the user has nothing
[00:39:35] about the class because
[00:39:37] it owns the class the class is the one
[00:39:39] who references the owner
[00:39:42] now the instructor is also teaching a
[00:39:44] class so as such they have their
[00:39:46] instructor id on the class
[00:39:49] and you'll notice that these are two
[00:39:50] separate one-to-many relationships but
[00:39:52] through them we have the ability for a
[00:39:55] user to have multiple classes and then
[00:39:57] each of those classes could have
[00:39:59] different instructors
[00:40:01] and because of that you could say that a
[00:40:03] user has many instructors through this
[00:40:06] class table and that's true in inverse
[00:40:09] as well
[00:40:10] okay we're back in
[00:40:12] postico world and we're ready
[00:40:15] to create
[00:40:16] our post table
[00:40:18] so let's go ahead and start with create
[00:40:20] table you guys know this now we're going
[00:40:22] to create the post table think about why
[00:40:25] i don't have to wrap this in quotes
[00:40:27] remember back to past and the lecture
[00:40:29] why don't i have to wrap that in quotes
[00:40:31] make sure you know make sure you know
[00:40:33] why
[00:40:34] i'm going to create the table post it's
[00:40:36] going to need just like every table an
[00:40:38] id which is a serial primary key
[00:40:42] and then we're going to give it a name a
[00:40:43] name for the post itself maybe this is a
[00:40:45] varchar 255. you're maxing out at 255
[00:40:49] characters for the name
[00:40:51] then content which we can go ahead and
[00:40:54] make text
[00:40:55] and finally
[00:40:57] that foreign key what relates the post
[00:41:00] to the user is a user id each post will
[00:41:04] have the id associated with the user
[00:41:08] that made said post and we'll go ahead
[00:41:10] and just make it an integer
[00:41:14] next what we need to do is we need to
[00:41:16] tell postgres that this user id is not
[00:41:19] just a normal integer it's a special
[00:41:22] integer it's a foreign key and the way
[00:41:23] we do that is by creating a constraint
[00:41:26] we can come and say constraint
[00:41:30] constraint i can type i can text
[00:41:34] constraint and then we give the
[00:41:35] constraint a name i'll call it f key fk
[00:41:38] user which is just a convention it means
[00:41:40] foreign key for the user
[00:41:43] then
[00:41:44] we can say it's a four in
[00:41:47] key
[00:41:49] then we tell it what column the foreign
[00:41:52] key belongs to which is in our case is
[00:41:53] the user id
[00:41:55] next we tell it what that column is
[00:41:58] referencing well it references
[00:42:02] the
[00:42:03] user
[00:42:04] id column and now this here is
[00:42:06] referencing the table so we'll say user
[00:42:10] and id
[00:42:12] so again at the end of our create table
[00:42:14] we're creating a constraint the
[00:42:15] constraint is that we have a foreign key
[00:42:18] the foreign key here is what column
[00:42:20] we're talking about the user id
[00:42:23] and then we tell it what that foreign
[00:42:25] key is for it's referencing
[00:42:27] the user table
[00:42:29] id column so we're saying this user id
[00:42:33] column in the post table is referencing
[00:42:36] the id column in the user table
[00:42:39] we'll go ahead and execute that
[00:42:40] statement and our table is made
[00:42:42] if we go ahead and refresh post to go
[00:42:45] here we'll see now that that post table
[00:42:47] is there
[00:42:48] and if we look it has this nice
[00:42:50] structure tab for us
[00:42:52] just for us to confirm that it worked
[00:42:54] we'll see user id and i know it might be
[00:42:56] a bit small but here where it has a
[00:42:59] constraint where it's referencing it's
[00:43:01] got this arrow to user.id it's a foreign
[00:43:04] key we've got it separate or we've got
[00:43:06] it set up properly
[00:43:09] okay we made our table with the foreign
[00:43:11] key let's go ahead and insert into this
[00:43:14] table
[00:43:15] so
[00:43:16] we could just write an insert but
[00:43:18] remember we have a constraint each post
[00:43:21] needs to belong to a user so let's just
[00:43:23] quickly review what users we have in our
[00:43:27] table and excuse me i have to wrap that
[00:43:29] in double quotes
[00:43:31] and there we go we have just the one and
[00:43:33] they've got the id of one so let's
[00:43:34] remember that we're inserting for id one
[00:43:37] so we'll go ahead and construct our post
[00:43:39] insert now we'll do insert into post
[00:43:43] and again we don't have to wrap this in
[00:43:45] double quotes you guys know that
[00:43:47] the values we'll insert are the name
[00:43:49] then the content and the user id
[00:43:53] and we say the values
[00:43:55] maybe this post is why
[00:43:58] i love corgis
[00:44:03] the content
[00:44:04] is oh my god i love them
[00:44:08] and the user who made them was user one
[00:44:10] he's a big corgi fan
[00:44:13] we can go ahead and insert them
[00:44:16] and then if we look at the post table
[00:44:22] we're gonna see sure enough
[00:44:25] the corgi
[00:44:27] post is there
[00:44:30] now let's go ahead and insert some more
[00:44:31] so we'll bring back i just undid a
[00:44:34] a bit to get back to the insert post
[00:44:37] excuse me there
[00:44:40] so we're inserting the post why i love
[00:44:42] corgis omg i love them
[00:44:44] let's just say why i love dogs in
[00:44:46] general
[00:44:48] uh
[00:44:49] so much
[00:44:50] and it was also made by user one
[00:44:54] uh
[00:44:55] what did i do wrong here uh content user
[00:44:58] id omg why i love it so much
[00:45:02] i don't see i don't see it do you guys
[00:45:04] see it you see where i made my mistake
[00:45:14] got i love them in general
[00:45:16] oh oh oh oh my goodness something good
[00:45:19] this is a good call out something good
[00:45:20] to know about postico is that if you
[00:45:22] highlight something and hit execute
[00:45:24] selection it's just going to execute
[00:45:25] that we want to execute the whole
[00:45:27] statement okay i'm not i'm not going
[00:45:29] insane this is this is correct okay we
[00:45:31] inserted the post now so if we go back
[00:45:33] and we say select star from post
[00:45:38] and end it with a semicolon
[00:45:41] um there we go we've got these two posts
[00:45:44] in place
[00:45:47] okay perfect
[00:45:49] so
[00:45:50] we've got our two posts in place that's
[00:45:52] great and we can see that those both
[00:45:54] belong to user one and that's how we get
[00:45:57] that one to many right this user one has
[00:45:59] many posts
[00:46:01] because we've got two separate posts
[00:46:03] with the user id one it works
[00:46:06] now the question is
[00:46:08] how do we say i want the user along with
[00:46:11] their posts that seems like an
[00:46:14] interesting piece of data to retrieve
[00:46:17] the way that we
[00:46:19] select data from multiple tables is by
[00:46:22] leveraging a join now there's multiple
[00:46:25] types of joins there's an inner join an
[00:46:27] outer join a left join and a right join
[00:46:30] but diving into them super thoroughly is
[00:46:33] probably a good topic for a future
[00:46:35] postgres video because we're just trying
[00:46:37] to talk about the basics and for now
[00:46:39] let's just talk about inner joins
[00:46:42] so what we can do is we can start from
[00:46:45] the user table
[00:46:46] so we'll go from the user table select
[00:46:48] from user
[00:46:51] there we go there's our user data
[00:46:53] and then what we can do
[00:46:54] is we can tell this table that it needs
[00:46:57] to also join
[00:47:00] to the posts table
[00:47:03] so i'm saying select from users table
[00:47:06] join it to the posts table so we're
[00:47:08] going to combine those two tables
[00:47:09] together and then we need to tell it on
[00:47:12] what place does it join well it joins on
[00:47:15] where
[00:47:17] the post table
[00:47:20] user id
[00:47:22] is the same as the user id
[00:47:26] so we've got these big tables and what
[00:47:28] we're saying is wherever the post table
[00:47:32] has a user id
[00:47:34] that lines up with one of the ids of a
[00:47:38] user
[00:47:38] we're going to match those things
[00:47:40] together so what we'll see here is we'll
[00:47:43] see two rows because there's two
[00:47:45] separate posts but for each one they've
[00:47:48] lined up with the user id one because
[00:47:51] we're joining
[00:47:52] wherever the post user id is you know
[00:47:55] the user id so give me
[00:47:57] um for a post like this first post all
[00:48:00] right let's talk about the second one
[00:48:01] like the second post give me the user
[00:48:03] information
[00:48:05] where the user's id in this case one
[00:48:08] lines up with our post user id column
[00:48:11] and there we go it lines up
[00:48:14] so there's our join
[00:48:15] but you might notice something here
[00:48:17] we have two name columns which is fine
[00:48:20] for us viewing it here
[00:48:21] but
[00:48:22] what if we're using this in an
[00:48:24] application and these become variables
[00:48:26] in some other programming language
[00:48:29] well you can't have variables with the
[00:48:31] same name in most languages so it's
[00:48:33] probably useful
[00:48:35] to
[00:48:36] know how we can reference these things
[00:48:38] differently well remember the star means
[00:48:40] select everything
[00:48:42] and we can change it up a little bit we
[00:48:44] can say select everything from the user
[00:48:47] table
[00:48:51] so we'll say user star but then maybe
[00:48:53] from the post table we'll get the post
[00:48:56] id
[00:48:57] the post
[00:49:00] name but then we'll tell it to not call
[00:49:03] it post name we'll say call it
[00:49:07] title as title
[00:49:09] then we can say get me the post content
[00:49:12] and get me the post
[00:49:14] user id
[00:49:17] now what you'll notice is when we run
[00:49:19] this
[00:49:20] it's the same data but it's gone ahead
[00:49:22] and it's changed and it might be hard to
[00:49:24] see but now
[00:49:25] the title
[00:49:27] of the post or i should say the name of
[00:49:29] the post is now called title and that
[00:49:31] doesn't change anything in the table
[00:49:33] itself it's just changing the results we
[00:49:35] get back with our select statement
[00:49:39] so that covers the basics of joints in
[00:49:41] future videos we'll be talking about
[00:49:43] more complex joints more complex schema
[00:49:46] design as well as
[00:49:48] triggers
[00:49:50] postgres functions
[00:49:51] and more complex constraints
[00:49:54] thank you so much for watching this
[00:49:56] video if you found it helpful please
[00:49:58] consider giving it a like and if you
[00:50:01] have any feedback it would be great to
[00:50:02] hear about it in the comments down below
[00:50:04] i hope that this video was useful for
[00:50:06] you and helps you get started in
[00:50:09] postgres please consider subscribing so
[00:50:11] that in the future any additional
[00:50:13] content i release you're able to get
[00:50:15] notified for whether that's additional
[00:50:17] postgres tutorials or just general
[00:50:19] software engineering advice and
[00:50:20] tutorials you'll see it all on this
[00:50:22] channel so subscribing is probably a
[00:50:25] good idea
