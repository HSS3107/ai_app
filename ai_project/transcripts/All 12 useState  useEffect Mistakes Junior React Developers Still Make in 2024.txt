Title: All 12 useState & useEffect Mistakes Junior React Developers Still Make in 2024
Channel: ByteGrad
Published: 2023-08-21T10:00:00Z
Duration: PT46M15S
Description: üëâ NEW React & Next.js Course: https://bytegrad.com/courses/professional-react-nextjs
Hi, I'm Wesley. I'm a brand ambassador for Kinde (paid sponsorship).
üëâ Add auth to your app FAST: https://bit.ly/3QOe1Bh

üëâ NEW React & Next.js Course: https://bytegrad.com/courses/professional-react-nextjs
üëâ Professional JavaScript Course: https://bytegrad.com/courses/professional-javascript
üëâ Professional CSS Course: https://bytegrad.com/courses/professional-css

üëâ Discord: all my courses have a private Discord where I actively participate
üîî Email newsletter (BIG update soon): https://email.bytegrad.com

‚è±Ô∏è Timestamps:
0:00 Intro
0:06 12/12 - State updates aren't immediate
2:35 11/12 - Conditional rendering
4:46 10/12 - Updating object state
7:59 9/12 - 1 Object state instead of multiple smaller ones
11:25 8/12 - Information can be derived from state / props
14:32 7/12 - Primitives vs non-primitives
19:05 6/12 - Initializing state with object
22:12 5/12 - TypeScript mistakes
27:19 4/12 - Not using custom hooks
30:59 3/12 - Server & Client components
33:08 2/12 - Stale closure
38:42 1/12 - Fetching in useEffect

#webdevelopment #programming #coding

Transcript:

[00:00:00] in this video we'll talk about the top
[00:00:01] 12 mistakes that Junior react developers
[00:00:03] make when it comes to the use State and
[00:00:04] use effect hooks in react number 12.
[00:00:07] let's say we have a simple counter
[00:00:08] component here I have a simple button
[00:00:10] here on the page and it's showing us the
[00:00:11] count is Count when I click the button
[00:00:13] we have handle click and that's going to
[00:00:15] set the count to count plus one and it
[00:00:17] looks like this and it works as expected
[00:00:19] now what if you do this so I'm
[00:00:21] duplicating the line here because let's
[00:00:22] say we want to do it again right after
[00:00:25] this we want to do it again the
[00:00:26] expectation now is that it will increase
[00:00:28] by two when we click Let me refresh here
[00:00:30] for a clean slate I'm going to click we
[00:00:32] don't see an increase of 2 we actually
[00:00:33] see an increase of one still and no
[00:00:35] matter how many times I add this and
[00:00:37] refresh here if I click here you will
[00:00:40] see it does not increase by anything
[00:00:41] more than one every time I click it
[00:00:43] still increases by one and not by four
[00:00:45] as you would expect maybe because when
[00:00:47] you set the count this is basically
[00:00:49] scheduling a state update so in this
[00:00:51] line we're scheduling that sometimes in
[00:00:53] the future reacts will update the count
[00:00:55] so then when you go to the next line
[00:00:56] it's not like the account variable has
[00:00:58] already updated this one has been set
[00:01:00] scheduled and this one will also
[00:01:01] schedule some update in the future but
[00:01:03] still using that same count variable so
[00:01:05] if I first load the page here initially
[00:01:07] this is going to be zero and this will
[00:01:09] also be zero if we click on the button
[00:01:11] now this count is simply zero so it's
[00:01:13] going to be zero plus one and the result
[00:01:15] of that is one and it will be scheduled
[00:01:17] in the future so when we get to this
[00:01:19] line count is still zero it isn't one
[00:01:21] yet so it's still zero so this will also
[00:01:23] schedule the count to be one in the
[00:01:25] future when we get to this line counter
[00:01:26] still zero it hasn't been updated yet
[00:01:28] and the same for this so they're all
[00:01:29] gonna set counts to one so if I save
[00:01:32] here you can see if I click once the
[00:01:34] count is simply becoming one and
[00:01:36] therefore it doesn't become four as you
[00:01:37] would expect on the first click the
[00:01:39] solution here is to use the updater
[00:01:40] function version of updating the state
[00:01:42] so with you States you can also obtain
[00:01:44] like this with a function if you do it
[00:01:46] with a function you get the previous
[00:01:47] value as the argument you can use that
[00:01:49] previous value now instead of counts we
[00:01:51] can just say take the previous value and
[00:01:53] increment it by one this previous value
[00:01:55] is actually up to date so if you
[00:01:57] schedule something you basically can get
[00:01:59] access to the as here in the next line
[00:02:01] as long as you use that updater function
[00:02:03] so this is the most up-to-date value of
[00:02:05] that count variable so if we do it this
[00:02:07] way if I now save here and refresh the
[00:02:09] page now if I click you can see it
[00:02:11] increments to 4 if I click again it
[00:02:13] increases to 8 and it increases by 4
[00:02:15] every time I click now some people have
[00:02:17] taken this lesson and think that you
[00:02:18] should always update the state with this
[00:02:20] updater function and that's not entirely
[00:02:22] true you can still open like this
[00:02:24] there's nothing inherently wrong with
[00:02:25] updating like this however in this case
[00:02:27] when you have multiple set counts you
[00:02:29] may want to use that updater function
[00:02:30] and in all other scenarios essentially
[00:02:32] you can still use this you'll see
[00:02:34] another example of this later in the
[00:02:35] video number 11 conditional rendering
[00:02:38] let's say we have some kind of product
[00:02:39] card and in the props we get the ID so
[00:02:42] this component is responsible for taking
[00:02:43] some ID and just rendering the relevant
[00:02:45] product card for that ID now it's
[00:02:47] possible of course that the ID doesn't
[00:02:48] get passed wherever it's used it doesn't
[00:02:51] pass the ID so in that case we could
[00:02:53] simply return no ID provided right so
[00:02:55] then you don't get to this part right
[00:02:56] because we already use the return
[00:02:57] keyword here so it returns out of the
[00:02:59] function right component is just a
[00:03:01] function and react as soon as you have
[00:03:02] to return keywords you stop there it
[00:03:04] doesn't continue to hear so here the
[00:03:05] only thing we're doing here is just
[00:03:07] returning a string no ID provider so
[00:03:09] that's what we see the problems here
[00:03:10] will start if you try using hooks after
[00:03:12] that if block so maybe we do use stains
[00:03:14] here and we'll just say something set
[00:03:17] something blah blah and maybe you want
[00:03:19] to do a use effect so I will talk more
[00:03:21] about use effects but you could do
[00:03:22] something like this we have to use
[00:03:23] statehook and the user fax hook and we
[00:03:25] got red squiggly lines that's number
[00:03:26] good so let's take a look react hook you
[00:03:28] state is called conditionally it needs
[00:03:30] to be caught in the exact same order
[00:03:31] every component render and we get the
[00:03:33] same problem with use effect here so the
[00:03:35] problem is that sometimes this ID may
[00:03:37] not exist and therefore we already
[00:03:39] return out of the function here however
[00:03:42] sometimes the ID may exist actually most
[00:03:44] of the time it does exist and then we
[00:03:46] actually do use use this and use effect
[00:03:48] here they will actually be invoked and
[00:03:50] that's not allowed in react so this
[00:03:52] implication of the hooks always needs to
[00:03:54] be the same in every render so you could
[00:03:55] simply do it like this simply do it
[00:03:57] after the hooks now I got an error here
[00:03:59] because I should import this so let me
[00:04:01] quickly do that I will import both of
[00:04:03] them now I'm using next.js here and
[00:04:05] these days we have clients and server
[00:04:06] components we'll talk more about that in
[00:04:08] this video as well essentially you
[00:04:10] cannot use use State and use effect in
[00:04:12] server components so I have to make this
[00:04:14] a client component and don't worry we'll
[00:04:16] talk more about this later so now you
[00:04:18] can see all the errors are gone and this
[00:04:20] still works now as a matter of style I
[00:04:21] don't like to have these two returns in
[00:04:24] my component function so I would
[00:04:25] refactor this a little bit differently
[00:04:27] so I would do it in one return here and
[00:04:29] I would do something like if no ID then
[00:04:32] I would say no ID providers and
[00:04:35] otherwise if there is an ID I would
[00:04:36] simply render the product card there
[00:04:38] right so I would prefer to do something
[00:04:40] like this so then we can get rid of this
[00:04:42] and this will work the exact same but I
[00:04:44] think it looks better to only have one
[00:04:45] return keyword number 10 incorrectly
[00:04:47] updating an object's state so sometimes
[00:04:50] you're going to have an object in your
[00:04:51] state so let's say we have this object
[00:04:53] here it has a name property City and age
[00:04:56] and there can be other things in this
[00:04:57] form let's say we just have one input
[00:04:59] for now and of course when we start
[00:05:01] typing here when I say Tim for example I
[00:05:03] want to actually update the state here
[00:05:05] to be that name so what you can say is
[00:05:07] on change so every time there is a
[00:05:09] change in that input field run the
[00:05:11] function handle change so let's quickly
[00:05:13] create that function here handle change
[00:05:15] so we have this event and here when we
[00:05:17] try to update the objects we may do a
[00:05:19] couple of things wrong here so we cannot
[00:05:21] just say something like user.name is
[00:05:24] e.target.value right so basically this
[00:05:27] is going to be Tim and we're going to
[00:05:28] assign that to user.name but this will
[00:05:30] not work so let me log the user here so
[00:05:32] we can actually see what it will be so
[00:05:34] I'm going to console log the user you
[00:05:35] can see when I save here we can ignore
[00:05:37] These Warnings it's just going to be an
[00:05:39] object with name empty still so now I'm
[00:05:41] going to type something and now you can
[00:05:43] see when I type we actually get errors
[00:05:45] so this doesn't work and you may think
[00:05:47] oh yeah of course because we actually
[00:05:48] need to return an object here and this
[00:05:50] is an object so let's make this an
[00:05:51] object an internet object we have a name
[00:05:54] and we should simply set that name to
[00:05:56] e.target.value right so whatever we put
[00:05:58] in the input field so if I save here and
[00:06:00] now if I try typing here let's see what
[00:06:03] we get and let me add Ctrl log again so
[00:06:05] I'm logging the user objects and Let me
[00:06:08] refresh here for a clean slate okay so
[00:06:10] you can see initially we have this
[00:06:11] objects and now if I start typing you
[00:06:13] can see we get an object again and it
[00:06:16] has the name correctly as well but then
[00:06:18] it doesn't have the city and age
[00:06:19] properties that's how our objects here
[00:06:22] should have name but also a CD and H and
[00:06:24] when you do it like this this is a
[00:06:25] common mistake you are not copying over
[00:06:27] the city and age properties so what you
[00:06:30] want to do here is you can take the user
[00:06:32] objects here that we have and you can
[00:06:34] just spread that out over here this will
[00:06:37] copy all of those properties including
[00:06:39] name into this new object that we're
[00:06:41] passing to set user but then we have
[00:06:43] this name after that so this will
[00:06:45] override that so if we do this and now
[00:06:47] let me refresh for clean slate this is
[00:06:49] the initial object and now if I start
[00:06:51] typing you can see our object has the
[00:06:53] same properties with the updated name so
[00:06:55] this is the correct way of updating one
[00:06:57] property in an object here we are using
[00:06:59] this View user variable here in practice
[00:07:01] you do see a lot of people use the
[00:07:03] updater function here it's not necessary
[00:07:04] but a lot of people seem to do it we can
[00:07:07] get the previous value of user instead
[00:07:09] of using user we can just use brief
[00:07:11] error I get some strange issue with
[00:07:13] typescripts here we can ignore that but
[00:07:15] this is also a common syntax when we do
[00:07:17] this you have to pay attention to how
[00:07:18] you're returning something here so here
[00:07:20] it's a function now so now when you have
[00:07:22] the first curly Branch that's not going
[00:07:24] to be the opening curly branch of an
[00:07:25] object this is going to be the opening
[00:07:27] curly brightness of the function block
[00:07:28] so here what you can do is you can wrap
[00:07:30] it in parentheses so then you don't have
[00:07:32] to use the return keywords so here
[00:07:34] everything in the parentheses that's
[00:07:36] what you will return so you can run it
[00:07:37] like this and the errors will disappear
[00:07:39] or you can actually write the return
[00:07:41] keyword here so then you would go into
[00:07:42] the function block itself and then have
[00:07:45] an actual return statement here and we
[00:07:47] would return an objects here with these
[00:07:49] things in there and so now looks a bit
[00:07:50] strange with all these curly braces and
[00:07:52] parentheses right so really make sure
[00:07:54] you've mastered JavaScript itself check
[00:07:56] out the JavaScript course in the link
[00:07:57] this is another way of doing the same
[00:07:59] thing number 9. let's say you have a
[00:08:01] form with a lot of inputs so we have
[00:08:03] first name last name email password in
[00:08:05] the real world you can have forms with
[00:08:07] dozens of inputs and we want to keep
[00:08:09] state of all of that so let's say we
[00:08:11] have first name here and now a beginner
[00:08:13] may say oh we also need one for last
[00:08:15] name and email and password basically
[00:08:17] create a separate state for all of them
[00:08:19] and that's not what we want to do it's
[00:08:21] cleaner to just use one object here for
[00:08:23] the whole form so you can have an object
[00:08:26] as state and then it would just be let's
[00:08:28] say form set form and then in the form
[00:08:30] you would have a key for each input so
[00:08:33] first name maybe empty initially last
[00:08:35] name email password address ZIP code
[00:08:39] right so just use one big object for all
[00:08:42] of that now if you want to update this
[00:08:44] it's actually very easy you can just use
[00:08:46] one function so if I want to type here
[00:08:48] and this first name should get updated
[00:08:50] we've seen that you can use on change we
[00:08:52] want to run a function called handle
[00:08:54] change which we're going to Define here
[00:08:56] and we'll change all right and then we
[00:08:59] can just update that so we can say set
[00:09:01] form and we've seen how this works now
[00:09:03] right so now we want to update one
[00:09:04] property in an object so it should be an
[00:09:06] object that we have here we can spread
[00:09:08] the form here so we get all the contents
[00:09:10] of that form here and then we can
[00:09:12] overwrite something so here we want to
[00:09:13] override first name with whatever we put
[00:09:16] here and then we can get that from
[00:09:18] e.targets.value right so now this first
[00:09:21] name will get properly updated here in
[00:09:23] the form in practice you're gonna see
[00:09:24] this updater function format as well for
[00:09:27] this so here when you want to return
[00:09:28] something you do need to wrap it in
[00:09:30] parentheses or you need to use that
[00:09:32] return keyword like we saw before and
[00:09:34] then we can use previous instead of the
[00:09:36] form right so this is pretty common to
[00:09:38] see so now we have a dance we're setting
[00:09:39] a new object here we copy everything
[00:09:41] over from the form first and then we
[00:09:44] override the first name in this case and
[00:09:46] that's only the first name what if I
[00:09:47] type something from my last name here
[00:09:49] what we want to be able to do is just
[00:09:51] copy this for all the other ones as well
[00:09:53] and we can actually do that this is the
[00:09:54] best way to do this so now I added this
[00:09:56] to last name if I type here it's going
[00:09:58] to fire this function is going to set
[00:10:00] the first name here that's not what we
[00:10:02] want it should become last name so how
[00:10:04] do we solve this well these inputs they
[00:10:06] also have a name attribute so here the
[00:10:08] name is first name name is last name
[00:10:10] name is email name is passwords these
[00:10:12] names are the exact same as what we have
[00:10:15] in the objects for the keys here so what
[00:10:17] we can use is actually instead of hard
[00:10:19] coding first name here there is
[00:10:21] something else that we got in this event
[00:10:23] variable which is either target.name and
[00:10:25] we can use that for the object key here
[00:10:28] that we want to override and you can
[00:10:30] actually write this in JavaScript like
[00:10:31] this so you have square brackets and
[00:10:33] then you can just use e.target.name
[00:10:35] right so if I type here we're going to
[00:10:37] run the handle change function well this
[00:10:39] one has a name or first name so this
[00:10:41] will simply become first name and it
[00:10:43] will get the value that I type here and
[00:10:45] now if I type here the second one with
[00:10:47] last name as a name this one simply
[00:10:49] becomes last name with the value that I
[00:10:52] type here so that will properly update
[00:10:54] this part right so now we can simply use
[00:10:56] this handle change for all of the inputs
[00:10:58] here right so I can added to all of them
[00:11:00] like this right and if you want to use
[00:11:02] the updated function here it works the
[00:11:04] exact same you just make this a function
[00:11:06] and now the opening curly brace with
[00:11:08] functions is going to be like the
[00:11:09] opening of The Block so we need to wrap
[00:11:10] this in parentheses if we want to return
[00:11:12] this or we actually want to go in here
[00:11:14] and use the return keyword like we saw
[00:11:16] before right and then you would use
[00:11:18] previous to spread the previous value
[00:11:20] here and then override it like this but
[00:11:22] I prefer this syntax we don't need the
[00:11:24] previous value here all right number is
[00:11:26] let's say we have some kind of cart and
[00:11:28] this card is keeping track of the
[00:11:29] quantity and every time I click this
[00:11:31] button we run the function handle click
[00:11:33] which just increases the quantity by one
[00:11:36] right very straightforward now let's say
[00:11:37] we want to show the total price here as
[00:11:40] well so we need to keep track of the
[00:11:41] total price here so a beginner may think
[00:11:44] oh I'm gonna type I'm going to write a
[00:11:45] new state here so total price set total
[00:11:48] price and maybe we can say something
[00:11:50] like initially zero and then every time
[00:11:52] we update the quantity we want to update
[00:11:54] the total Prime so you may think I'll
[00:11:56] use a user facts right so here we can
[00:11:58] say use effects we want to to run this
[00:12:00] function every time the quantity changes
[00:12:02] so you have a dependency array and every
[00:12:04] time this quantity variable changes we
[00:12:06] want to run this function in that
[00:12:08] function we can set the total price to
[00:12:10] well what is going to be the dollar
[00:12:12] price well that's always quantity times
[00:12:14] the price per item so now what we have
[00:12:17] is every time I click here we run this
[00:12:19] function and it will update the quantity
[00:12:21] which means that this user fact now will
[00:12:23] also run and it will set the total price
[00:12:25] but it makes sense logically when you
[00:12:27] think about it like that and now we can
[00:12:28] just output this on the page the total
[00:12:30] price is going to be something so now we
[00:12:32] have one initially and this will also
[00:12:34] run initially so it's going to be 1
[00:12:37] times 5 is 5. if I click again it's
[00:12:39] gonna add another five right because
[00:12:41] quantity obtains quantity becomes 2 and
[00:12:43] 2 times 5 is 10. every time a click it
[00:12:46] increases by five alright so this is
[00:12:48] very bloated and this is not necessary
[00:12:50] at all so here if we want to know the
[00:12:51] total price we don't need to use u stand
[00:12:53] or use effects right we can just remove
[00:12:55] that so I'll comment this out because we
[00:12:57] can derive it from the quantity and
[00:12:59] Enterprise per item so here you can just
[00:13:01] create a variable in your function body
[00:13:03] there's no you can do that and you can
[00:13:05] say the total price this is going to be
[00:13:06] a variable total price and that's going
[00:13:08] to be the quantity times the price per
[00:13:10] item right you can do this of course if
[00:13:12] I save here and start from a clean slate
[00:13:15] if I now click it still works the exact
[00:13:17] same because what happens is initially
[00:13:18] when it first renders this components it
[00:13:20] will go in the function body here line
[00:13:22] by line the quantity will be one it's
[00:13:24] going to do one times price and which we
[00:13:26] have set as five so then here total
[00:13:28] price is five then if I click handle
[00:13:31] click this function will run it will
[00:13:32] update the quantity which will re-render
[00:13:34] this component so we will go into the
[00:13:36] function body again this time quantity
[00:13:38] will be 2 because we added one and then
[00:13:40] we run this line again this statement
[00:13:42] should will be 2 times the price per
[00:13:43] item which is 10. so now total price is
[00:13:45] 10 and it will be output on the page
[00:13:47] right so you can see that you don't need
[00:13:49] all these hooks every time if you can
[00:13:51] derive it or calculate it from already
[00:13:53] existing States you don't need to create
[00:13:55] new state and use use effects another
[00:13:57] typical example of this is for example
[00:13:59] if you have the first name of somebody
[00:14:01] right so we have first name and then
[00:14:03] maybe also keeping track of the last
[00:14:05] name right and now you want to know the
[00:14:07] full name so you think oh well full name
[00:14:09] well we're just going to create a new
[00:14:10] you state for that and for full name and
[00:14:12] that's not necessary we can derive it
[00:14:13] from already existing States right so
[00:14:15] you can say full name well not simply
[00:14:17] the first name plus the last name right
[00:14:20] no State no use effect needed every time
[00:14:22] one of these updates the function will
[00:14:25] re-render it will go statement by
[00:14:26] statement again so every time the full
[00:14:28] name will get updated as well right so
[00:14:30] very typical Junior developer mistake
[00:14:32] all right number seven Primitives versus
[00:14:34] non-primitive values let's say we have a
[00:14:36] price component and we just have a
[00:14:37] simple button here and when we click the
[00:14:39] button we run a function called handle
[00:14:41] click which we have defined here and the
[00:14:42] only thing it does is set the price to
[00:14:44] zero every time right so initially it's
[00:14:46] zero and this one is also gonna set the
[00:14:47] price to zero now you probably learned
[00:14:49] that if the state doesn't change the
[00:14:51] component doesn't re-render rendering a
[00:14:53] component just means in the function
[00:14:55] body we just run all the statements
[00:14:57] again so we just run the entire thing
[00:14:58] again so let's do that's actually true
[00:15:00] let's just log something at the start of
[00:15:02] the components here component rendering
[00:15:04] so we're going to lock this and I'm
[00:15:06] going to open up the dev tools console
[00:15:08] here I'm going to clear everything here
[00:15:09] so now if I click this button let's see
[00:15:11] what happens so now if I load the page
[00:15:13] and this component first mounts we see
[00:15:16] component rendering right so when it
[00:15:18] first mounts it's going to run all the
[00:15:19] statements in the function body here so
[00:15:21] we indeed log this now if I click again
[00:15:23] and I keep clicking you can see it
[00:15:26] doesn't say component rendering again
[00:15:28] because here it can see that this is the
[00:15:30] same value as it already is right so it
[00:15:32] won't re-render the component and that
[00:15:34] is true if you have a number or a string
[00:15:36] so now if I try to set it to a string
[00:15:39] called test now I'm keeping the state a
[00:15:41] string called test restart here from
[00:15:43] clean slide now if I click again you can
[00:15:45] see it doesn't re-render same with a
[00:15:46] Boolean so if I set it to true and I set
[00:15:48] the price to True whenever I click the
[00:15:50] button let me restart again now I'm
[00:15:52] going to click here you can see now
[00:15:53] re-rendering however what if we actually
[00:15:55] have an object here this may actually
[00:15:57] describe the price so it may have a
[00:15:58] number for the price let's say 100 and
[00:16:01] it may also have some kind of Boolean in
[00:16:03] there so total total price true right so
[00:16:06] now the price variable here is an object
[00:16:08] with these two properties and what
[00:16:09] happens if we set the price to an object
[00:16:12] with the exact same properties and
[00:16:14] values so I'm going to copy this I'm
[00:16:16] going to save here and refresh here for
[00:16:18] a clean slate so now what happens is
[00:16:20] whenever I click you can see the
[00:16:22] component re-renders why is that because
[00:16:24] you think when you look at this
[00:16:25] officially speaking it looks the exact
[00:16:27] same but I didn't make a typo or
[00:16:29] anything right it's the exact same state
[00:16:31] you would say and why is it re-rendering
[00:16:33] well that's because in JavaScript there
[00:16:35] are primitive values that we just saw
[00:16:37] that are passed by value and the objects
[00:16:39] and arrays are passed by reference so if
[00:16:42] I have a variable a that's the number
[00:16:43] five let's say and I have a variable B
[00:16:46] that is also the number five if I say a
[00:16:49] is strictly equal to B JavaScript tells
[00:16:51] me that's true if I have a variable
[00:16:53] called C with the string test and a
[00:16:56] variable D with the string test if I say
[00:16:58] C is straight to equal to D JavaScript
[00:17:00] will tell me that's true however what if
[00:17:02] we now have an object so let's say I
[00:17:04] have an object Y and I have a key of
[00:17:07] hello is one let's say so this is an
[00:17:10] object and now I also have another
[00:17:11] object which also has hello is one and
[00:17:15] it's the exact same right you would say
[00:17:16] so now I'm gonna write Y is strictly
[00:17:18] equal to Z and JavaScript is telling me
[00:17:21] that's false because in JavaScript
[00:17:22] whenever you write an object literal
[00:17:25] like this you're not actually working
[00:17:26] with the object itself you're working
[00:17:28] with a reference a pointer and this is a
[00:17:30] bit tricky to understand but what you
[00:17:32] need to know is that this is not the
[00:17:34] actual value that you're working with
[00:17:35] you're working with an address and the
[00:17:37] address for this object is going to be
[00:17:39] different from the address of this
[00:17:41] object so an object is more like a box
[00:17:43] in the real world you can have one box
[00:17:45] with the exact same contents as another
[00:17:47] box but there are two different boxes
[00:17:49] right an object may have the exact same
[00:17:51] contents as another object as the exact
[00:17:54] same contents here but there's still two
[00:17:55] different objects and that's not true
[00:17:57] with strings and numbers and Boolean so
[00:18:00] they are always the exact same you
[00:18:01] actually work with their actual value
[00:18:03] here you work with their reference so
[00:18:05] here what happens is we have this object
[00:18:07] here and when we click we're setting it
[00:18:09] to this object and this is a different
[00:18:11] object right and reacts will see oh
[00:18:13] you're passing something new here this
[00:18:15] is different from what we had before
[00:18:16] because it's a different object and
[00:18:18] therefore react will say well it's
[00:18:19] different so we're going to re-render
[00:18:21] that's why when I click here it keeps
[00:18:23] re-rendering in practice this is mostly
[00:18:25] dangerous for when you have some kind of
[00:18:27] dependency array most commonly with use
[00:18:29] effects the way it works is you're going
[00:18:30] to run this function every time what you
[00:18:33] specify here in the dependency array so
[00:18:35] if you have it empty it's just gonna run
[00:18:36] only once when it first mounts but you
[00:18:39] can also specify a variable here like
[00:18:40] price and now every time price changes
[00:18:43] this function will run as well now you
[00:18:44] want to be careful with this because
[00:18:46] this object is going to change every
[00:18:48] time you update it so typically you
[00:18:50] don't want to depend on an object you
[00:18:52] want to depend on a primitive value like
[00:18:54] a number Boolean string so you can also
[00:18:55] just look at the contents of the objects
[00:18:57] so you can say price at number number so
[00:18:59] now you're just depending on a primitive
[00:19:02] which will prevent this use effect
[00:19:03] function from unnecessarily running
[00:19:05] number six initializing state with an
[00:19:07] object so let's say we have some kind of
[00:19:09] blog post component and here we have the
[00:19:12] post and we can set the post and here we
[00:19:14] have a use effect so use effect the way
[00:19:16] it works is we have this function here
[00:19:18] and with the dependency array we
[00:19:20] determine when it should run so an empty
[00:19:22] dependency array means it's only going
[00:19:23] to run when it first mounts when the
[00:19:25] component mounts it's going to fetch the
[00:19:26] past eventually it gets a response it
[00:19:28] will parse that response as Json meaning
[00:19:30] it will convert it from Json to a normal
[00:19:32] JavaScript object so we can work with
[00:19:34] that that's going to be data here and
[00:19:36] that's what we're going to set the post
[00:19:37] as and this can take some time can take
[00:19:38] multiple seconds but here we are already
[00:19:40] rendering post the title post.body so if
[00:19:43] I save here let's actually see what we
[00:19:44] get so here you can see again an error
[00:19:46] because initially it says something but
[00:19:48] cannot read properties of undefined so
[00:19:50] we have post.title but poster title is
[00:19:52] undefined because I haven't specified an
[00:19:55] initial value here right so initially
[00:19:57] post is going to be undefined so here
[00:19:58] immediately you're going to try to
[00:20:00] undefined that title and that's not
[00:20:01] possible you're going to get an error
[00:20:03] and also remember use effects runs after
[00:20:05] rendering so first you try to render
[00:20:07] this on the page and then after that use
[00:20:09] effect round and so make sure you've
[00:20:11] mastered the reacts fundamentals check
[00:20:12] out my react next to escorts so while
[00:20:14] we're waiting for this to finish and we
[00:20:16] actually have to post data we are
[00:20:18] already trying to access post.title so
[00:20:20] post this initially undefined and if you
[00:20:22] try to access something on undefined in
[00:20:24] JavaScript you're going to get this
[00:20:25] error so one way around this is to use
[00:20:27] optional chaining so we're basically
[00:20:29] saying post may not exist it may be
[00:20:31] undefined so if we try to access
[00:20:33] something don't throw an error so if I
[00:20:35] save here we don't get an error and now
[00:20:37] we actually get the data as well now
[00:20:39] typically people initialize this not
[00:20:40] with undefined or leaving it empty it's
[00:20:42] better to make it explicit that it's
[00:20:44] initially null and in JavaScript if you
[00:20:46] want to Mark something explicitly as not
[00:20:49] existing you use null undefined is more
[00:20:51] accidentally not existing essentially no
[00:20:54] is when you are really deliberate about
[00:20:55] it so here we are deliberate initially
[00:20:57] it's empty right so 40 the empty State
[00:21:00] initially it should be null so initially
[00:21:02] it's going to be null and then we can
[00:21:03] try accessing title and body and it
[00:21:05] works the same way here so if I remove
[00:21:07] this initially we're going to get an
[00:21:09] error because title you cannot access
[00:21:10] that title or no so we could do this
[00:21:12] optional chainings thing we could do
[00:21:14] this but a cleaner solution is to use
[00:21:16] some kind of loading state so what we
[00:21:18] want to do is simply not render anything
[00:21:19] until we actually have the data from the
[00:21:22] post right that makes much more sense so
[00:21:23] what we can do here is we can have
[00:21:25] something like loading if it's true we
[00:21:27] may just want to say nothing or maybe
[00:21:29] loading dot dot and otherwise if it's
[00:21:32] not loading we actually want to display
[00:21:34] this title and body here we do actually
[00:21:36] want to display in the title and body so
[00:21:38] I'm going to put this in a react
[00:21:39] fragment because I don't want to clutter
[00:21:41] up the markup with divs or anything we
[00:21:43] don't need a div okay so then we have
[00:21:45] loading and then we can just have a
[00:21:47] state for loading so we can check if
[00:21:49] it's still loading so we can say loading
[00:21:50] initially is true right and then here it
[00:21:53] starts fetching this and eventually it
[00:21:54] has received data and we can set loading
[00:21:57] set loading to false that so we can do
[00:21:59] this so now let's see what we got if I
[00:22:01] save here the error should disappear we
[00:22:03] get a loading State and then we get the
[00:22:04] nice post right so this is a much
[00:22:06] cleaner solution now you don't really
[00:22:07] want to fetch yourself in use effects
[00:22:09] and we'll talk more about this later in
[00:22:11] the video so keep watching number five a
[00:22:13] very typical typescript mistake and
[00:22:14] react you don't have to understand
[00:22:16] typescript right now this will be a good
[00:22:17] introduction so you can see my file now
[00:22:19] is called dot TSX previously I had jsx
[00:22:23] this is plain JavaScript and TSX you can
[00:22:25] use typescript now when you do that and
[00:22:27] we take the previous example remember we
[00:22:29] had this post initially the post is no
[00:22:31] so post is going to be null and here in
[00:22:33] rendering we also have loading state so
[00:22:35] here if it's loading we just want to
[00:22:37] render loading and then here we're
[00:22:39] fetching the data when the component
[00:22:41] first mounts it's an empty array so only
[00:22:43] once when it first mounts it will fetch
[00:22:45] the post and eventually when we get the
[00:22:47] response we set the post to the data and
[00:22:49] we also set loading to files so here
[00:22:51] when loading is false the post has been
[00:22:53] fetched and we want to display the title
[00:22:55] and body now previously we didn't get
[00:22:57] any rats quickly lines but now that I
[00:22:58] enable typescript we see these rats
[00:23:00] quickly lines so touchscreen is giving
[00:23:02] us a warning here essentially and it's
[00:23:04] saying post is of type null and that's
[00:23:06] because with typescripts in react if
[00:23:08] you're using State here typescript can
[00:23:11] infer what the type of this variable is
[00:23:13] going to be so for loading here for
[00:23:15] example if I hover loading typescript is
[00:23:17] telling me loading is going to be of
[00:23:19] type Boolean how does it know that I
[00:23:21] have not specified this myself I could
[00:23:23] specify it myself and the way you would
[00:23:25] specify it is with this weird looking
[00:23:27] angled brackets you could say this
[00:23:29] loading State let me make this wider
[00:23:31] this loading state is going to be of
[00:23:32] type Boolean so we're going to see
[00:23:34] loading as Boolean but typescript could
[00:23:36] already infer that so we don't need to
[00:23:38] do that and so typescript can infer from
[00:23:40] the initial value that you pass in what
[00:23:42] type it's going to be so if you have
[00:23:44] text here for example initially that may
[00:23:46] be a string now I could specify string
[00:23:49] here I could tell typescript hey this
[00:23:51] variable here text is going to be of
[00:23:53] type string but I don't need to do that
[00:23:55] because typescript can see this oh this
[00:23:57] is going to be a string so if I hover
[00:23:58] this you you can see it has already been
[00:24:00] inferred as a string by the way what's
[00:24:02] the benefit of this okay so typescript
[00:24:04] knows that text is going to be a string
[00:24:05] so what if typescript has the correct
[00:24:07] type here for its string typescript can
[00:24:09] then help us out so here let's say in
[00:24:11] the rendering here I'm trying to do
[00:24:12] something with text so I can try to
[00:24:15] upper case I can try to replicate it and
[00:24:17] typescript will not give me a warning
[00:24:19] because it knows that two uppercase is
[00:24:21] indeed a method that you can use on a
[00:24:23] string however if I try doing this on
[00:24:25] loading the loading variable which is a
[00:24:28] Boolean right touchgrid has inferred
[00:24:30] this to be a Boolean if I try to do
[00:24:32] something like two uppercase touchgrip
[00:24:33] will tell us that this two uppercase
[00:24:35] does not exist on this type right so
[00:24:37] touchgrip will help us out if we or
[00:24:39] somebody on our team makes a mistake and
[00:24:41] also when we try setting the state here
[00:24:43] let's say set loading if I try to make
[00:24:45] this for example a string files Tasker
[00:24:48] will help us out it will say well you
[00:24:49] cannot assign a string because this
[00:24:51] loading is supposed to be a Boolean
[00:24:53] right so here we're trying to assign a
[00:24:54] string here right string happens to be
[00:24:56] false by correctly typing things we get
[00:24:58] these guard rails from touchscreen and
[00:25:00] the same with count for example so these
[00:25:02] are all primitive values that maybe
[00:25:04] count initially is the number 100. I
[00:25:07] could specify this count is going to be
[00:25:08] of type number but I don't need to if I
[00:25:10] leave this now typescript can look at
[00:25:12] the initial value and see how this is
[00:25:13] going to be of type number right so here
[00:25:15] count is going to be of type number
[00:25:16] touches can automatically infer that
[00:25:18] when you use a primitive value like a
[00:25:20] Boolean string or number that's not the
[00:25:22] case when you have these objects so here
[00:25:24] with objects initially we want to have
[00:25:26] null but later we know that it's not
[00:25:28] going to be null we're actually going to
[00:25:30] set it to some data and this is quite
[00:25:32] common when you have some fetching in
[00:25:34] your component so how do we type this
[00:25:35] then because initially it's going to be
[00:25:37] null so if I hover post now you can see
[00:25:39] typescript has inferred this to be of
[00:25:41] type null and if it's of type null you
[00:25:43] cannot access title and Body on post and
[00:25:45] now we actually do need to specify what
[00:25:48] type it's going to be so we have these
[00:25:49] built-in types like string and number
[00:25:52] and Boolean but we can also create our
[00:25:54] own type so we can say eventually this
[00:25:56] is going to be of type post right so now
[00:25:58] we need create a type so we have type
[00:26:00] and we can call that post we can say
[00:26:02] that's going to be an object so we have
[00:26:04] curly branches it's going to be an
[00:26:05] object and let's see it's going to have
[00:26:07] a title and body so we say the time
[00:26:09] there's going to be a title and that's
[00:26:10] going to be of type string it's also
[00:26:12] going to be a body and that's also going
[00:26:13] to be of type string and you could have
[00:26:14] other things here maybe this post has
[00:26:16] tags for example and maybe it's an array
[00:26:19] of strings so we can have string and
[00:26:20] then you can have the array symbol and
[00:26:23] now you're saying these tags are going
[00:26:24] to be an array of strings right and we
[00:26:25] have number Boolean Etc so now we're
[00:26:28] telling typescript this post variable is
[00:26:30] going to be of type post and now it
[00:26:32] knows it's going to be of type post and
[00:26:33] post has subtitle and body so now we can
[00:26:36] safely access title and body you can see
[00:26:38] we are we don't have red squiggly lines
[00:26:39] anymore but now we got red squiggly
[00:26:41] lines here under null so what's going on
[00:26:43] here well this is because we are telling
[00:26:45] taskgrave this post is going to be of
[00:26:47] this type but now what we're passing in
[00:26:49] is no so not saying hey you told me that
[00:26:52] it's gonna it's gonna be an object with
[00:26:53] title and body but what you're giving me
[00:26:55] here is null and that's simply because
[00:26:56] it's the initial value so typically what
[00:26:58] you want to do here is you can say it's
[00:27:00] going to be of type post or no so it
[00:27:03] could be null here initially but
[00:27:04] eventually it's going to be a type post
[00:27:06] and so touch screen looks a bit strange
[00:27:07] we have these angled brackets and this
[00:27:09] looks a bit confusing we talk a lot
[00:27:11] about typescript in my react and next to
[00:27:13] S course as well right so don't worry if
[00:27:14] you're not completely comfortable with
[00:27:16] this I will just use this from now on so
[00:27:17] you can learn a little bit about it
[00:27:19] number four not using custom hooks so
[00:27:21] Junior react developers seem to be a
[00:27:23] little bit confused or scared to use
[00:27:25] custom hooks so as an example I just
[00:27:27] have one component here and I have
[00:27:29] another component here right you can
[00:27:30] have multiple components in the same
[00:27:31] file that's not a problem all right now
[00:27:33] let's say that this component needs to
[00:27:34] know the width of the window so it could
[00:27:36] create a state for that window size set
[00:27:39] window size and maybe initially it's
[00:27:41] going to be 1920 and let me import this
[00:27:43] and we're using U stays here so I need
[00:27:46] to make this a client component we'll
[00:27:47] talk about that in a second and this
[00:27:49] stays here for Windows size we're going
[00:27:51] to keep track of that in use effects so
[00:27:53] use effect we want to run this function
[00:27:55] but only initially when the component
[00:27:57] first mounts and let me import with this
[00:27:59] and in this function we're simply going
[00:28:00] to attach an event listener to the
[00:28:02] window object so whenever it resizes we
[00:28:05] want to update the state so it's going
[00:28:06] to be this function that we want to
[00:28:08] attach so here this function will run
[00:28:09] every time there is a resize event now
[00:28:12] we'll talk more about this but these use
[00:28:13] effects they also have a so-called
[00:28:15] cleanup function because when this
[00:28:16] component unmounts for example maybe
[00:28:18] we're navigating away and this component
[00:28:20] should not be visible anymore this event
[00:28:22] listener is still attached to the window
[00:28:23] and we want to remove that when this
[00:28:25] component is not being used so in react
[00:28:27] you can also return a function here so
[00:28:29] this function will run when you unmount
[00:28:31] your component and in this function we
[00:28:33] can simply remove this event listener
[00:28:35] right so it's a cleanup function
[00:28:37] basically we need to clean up our mess
[00:28:38] basically before we completely remove
[00:28:40] this components it's also important to
[00:28:42] know the inner details of how all of
[00:28:44] this works the important Point here is
[00:28:45] that this is actually a quite common
[00:28:47] scenario you have some states and you
[00:28:49] update it in use effects and this is a
[00:28:50] lot of code now very commonly other
[00:28:52] components will want the same
[00:28:53] information so let's say this example
[00:28:55] component 2 also wants this code so a
[00:28:58] Eve react developer Junior react
[00:29:00] developer would simply duplicate all of
[00:29:02] tests they would also put all of this
[00:29:04] code in those other components so now
[00:29:06] we're going to bloat up all our other
[00:29:08] components that need access to that as
[00:29:10] well very duplicative code now now if
[00:29:12] you've learned JavaScript properly you
[00:29:13] may have heard of the dry principle
[00:29:15] don't repeat yourself so whenever you
[00:29:17] have some kind of repetition it's a good
[00:29:19] candidate for refactoring it into
[00:29:21] something that's a little bit more
[00:29:22] reusable and that's the same when you
[00:29:23] use hooks in react so here we can create
[00:29:25] a custom hook out of this and it sounds
[00:29:27] very fancy but it's just refactoring
[00:29:29] this into a separate sort of utility
[00:29:31] function or helper function essentially
[00:29:33] so let's see how we can do that so we
[00:29:35] can simply create that right here so we
[00:29:36] can just create a function now typically
[00:29:38] the name of these start with the word
[00:29:40] use to indicate that it will have
[00:29:43] reactor hooks in it and use window size
[00:29:45] let's say you can give it any name you
[00:29:47] want but this makes the most sense I
[00:29:48] think and then we're just going to put
[00:29:50] all of these cows in there so we're
[00:29:51] going to remove it from this component
[00:29:53] we're going to refactor it into one
[00:29:54] function here now we can remove it from
[00:29:56] this component and we can also remove it
[00:29:58] from desk components and no need to
[00:30:00] duplicate ourselves we're just going to
[00:30:01] refactor it into one function just like
[00:30:03] it would do otherwise in JavaScript if
[00:30:05] you have some kind of repetition it's
[00:30:06] the same in react the only difference is
[00:30:08] basically that you add the word use in
[00:30:10] front of it because you're using use
[00:30:11] State and use effect in there so this
[00:30:13] helps indicate that you're using these
[00:30:15] react features under the hood right and
[00:30:16] then you can just use that here so you
[00:30:18] can say use window size you can just
[00:30:20] call that function and it will basically
[00:30:22] run as the exact same as what we had
[00:30:24] before but I can add it here as well
[00:30:26] right so now this is much cleaner
[00:30:27] looking in the components now in the
[00:30:29] components we wanted access to the
[00:30:30] window size so now we do need to return
[00:30:32] the window size from this function so
[00:30:34] let's return window size and then we can
[00:30:37] just grab that here when we invoke it
[00:30:39] Windows size so this would be the
[00:30:41] complete example so here I would also
[00:30:43] add that so now we get access to the
[00:30:45] window size in these components but the
[00:30:47] code has been refactored into one
[00:30:49] function that we can reuse so that we
[00:30:51] don't load up our component with
[00:30:52] repetitive code right so don't be afraid
[00:30:54] to create custom hooks we talk a lot
[00:30:56] about this in my react next.js course as
[00:30:58] well number three these days we have
[00:31:00] server and client components in react if
[00:31:02] you're using next.js you may have
[00:31:04] already seen them if you're using feed
[00:31:06] or create reactor app you may have not
[00:31:07] seen them yet but this is basically the
[00:31:09] future of react so we need to know a
[00:31:11] little bit about how it works in
[00:31:12] relation to these hooks so I'm using
[00:31:14] nextges and specifically I'm using the
[00:31:16] app directory in next.js and by default
[00:31:18] your components are server components
[00:31:20] and that means they're only going to run
[00:31:22] on the server now on the server they
[00:31:24] will not keep track of state so if you
[00:31:26] try using use State here if I try doing
[00:31:28] this and even if I import it here if I
[00:31:31] save here I get an error basically I
[00:31:33] cannot use this in a server component I
[00:31:35] need to convert this into a client
[00:31:37] component I can do that by adding use
[00:31:40] client at the top now before I do that
[00:31:42] let me show you some other things that
[00:31:43] also don't work so use effect also
[00:31:45] doesn't work so this is a sort of a life
[00:31:47] cycle hook and you cannot do that on the
[00:31:49] server right so user fact will not work
[00:31:51] even if I import this right so here we
[00:31:53] get the same error so the other hooks in
[00:31:55] react also don't work here another thing
[00:31:57] that doesn't work is for example if if
[00:31:58] you do anything with the window objects
[00:32:00] so for example alerting does not work on
[00:32:03] the server right so on the server we
[00:32:04] don't have access to that window object
[00:32:06] so here we're going to get something
[00:32:07] like Windows not defined because there
[00:32:09] is no window on the server this has
[00:32:11] nothing to do with hooks but I just want
[00:32:12] to show you this also for example local
[00:32:14] storage right if we try to do some get
[00:32:16] item local storage does not exist on the
[00:32:18] server it only exists in the browser
[00:32:20] same from the window that's a browser
[00:32:22] feature the browser gives that to us so
[00:32:24] this is not going to be available on the
[00:32:25] server it's not going to be defined so
[00:32:27] whenever you need access to these
[00:32:28] client-side features you need to make
[00:32:30] this a client component there are two
[00:32:32] ways of doing that you can add use
[00:32:34] client at the top or not use this but
[00:32:37] you can import it into another component
[00:32:40] that is already a client component for
[00:32:42] example if another component has use
[00:32:44] client at the Top If you import into
[00:32:46] that other component this will
[00:32:48] automatically also become a client
[00:32:50] component so you can imagine a tree of
[00:32:52] components in react as soon as you add
[00:32:54] use client to some component all the
[00:32:56] other components that you imported there
[00:32:58] will also become clients components so
[00:33:00] this is basically like a boundary in
[00:33:01] your react 3. from now on everything
[00:33:03] here becomes a client component this is
[00:33:05] also something that we talk much more
[00:33:07] about in my react next to S course
[00:33:08] number two still closure so let's say we
[00:33:10] have some kind of counter component and
[00:33:12] it's just showing us count as count and
[00:33:14] we're keeping track of the count in this
[00:33:16] new state so far so good now let's say
[00:33:18] that every one second we want to
[00:33:20] increment this count by one so we can
[00:33:22] set up a set interval when this
[00:33:24] component first mounts so that's a life
[00:33:26] cycle thing so we can use use effects so
[00:33:28] we can say we want to run this function
[00:33:29] but only when this component first
[00:33:31] mounts input this so this function will
[00:33:34] run when the component first mounts and
[00:33:36] in there we want to set up an interfall
[00:33:38] as it calls in JavaScript so what we can
[00:33:40] do is we can say set interval and here
[00:33:43] we can say run this function every one
[00:33:46] second right so the first time this
[00:33:47] component mounts we're gonna set up this
[00:33:49] interval that will make this function
[00:33:51] run every one second right so what do we
[00:33:53] want to do in there well maybe we just
[00:33:55] want to log into file function running
[00:33:57] and of course we we want to do is we
[00:33:59] want to set the count to count plus one
[00:34:02] all right so let's save here and see
[00:34:04] what we get so now we can see that the
[00:34:06] number has increased to one but it stays
[00:34:08] there why doesn't it keep increasing it
[00:34:10] should increase every one second let's
[00:34:12] check if we can see the console log in
[00:34:14] the console tab I have a refresh here we
[00:34:16] start from scratch and we can see that
[00:34:18] the interval function is actually
[00:34:20] running you can see here that this
[00:34:22] interval function keeps going so every
[00:34:23] second this function is indeed running
[00:34:26] right so this function is actually
[00:34:27] running every second because we can see
[00:34:30] that this log well we can see this every
[00:34:32] second it doesn't need lock that right
[00:34:33] so if you keep blocking the same thing
[00:34:35] in the console tab the browser will just
[00:34:37] increment this it's not going to put
[00:34:39] everything here right but the count for
[00:34:40] some reason stays at one how is this
[00:34:42] possible this has to do with a closure
[00:34:44] in JavaScript so here initially count is
[00:34:48] zero the first time we Mount this
[00:34:49] component count is zero and then we're
[00:34:51] gonna run the use effect so this
[00:34:53] function this whole function will run
[00:34:55] once when the component mounts and then
[00:34:57] we're gonna run user fact and in the use
[00:34:59] effect we are setting up this interval
[00:35:01] function so basically this function will
[00:35:03] run every one second but JavaScript will
[00:35:06] not recreate the function every one
[00:35:08] second so it will just create this
[00:35:09] function once and then it will just
[00:35:11] execute that function every one second
[00:35:13] and in JavaScript these variables if you
[00:35:16] use a variable like count those are
[00:35:18] created at function creation time and at
[00:35:21] the time of creating this function count
[00:35:22] is zero right so this function is only
[00:35:25] created once and then it's just executed
[00:35:27] every one second you can see here that
[00:35:29] in set counts if you make the addition
[00:35:31] here it becomes one so this is created
[00:35:33] one time and then it's just doing set
[00:35:35] count is one every single time that's
[00:35:37] why you can see that interval function
[00:35:39] running well we can see that right so
[00:35:40] this confirms to us that it is actually
[00:35:42] running every one second but set count
[00:35:44] is just going to be one all the time so
[00:35:46] yeah it's just gonna stick there right
[00:35:47] and this is a very tricky mistake that
[00:35:49] some Junior reacts developers make right
[00:35:51] so this is called closure this variable
[00:35:52] is getting the value at function
[00:35:54] creation time and that's going to be
[00:35:56] zero simply so how do we make sure that
[00:35:58] this updated so that every one second it
[00:36:01] gets access to the new value well we
[00:36:03] need to make sure that every one second
[00:36:05] that function is actually destroyed and
[00:36:07] then recreated again so that in the new
[00:36:09] creation of that function it can simply
[00:36:11] get the new value well maybe we can add
[00:36:13] count to this array right so you could
[00:36:15] say we should just add count to this
[00:36:17] dependency array now use effects will
[00:36:19] run not only when we Mount the
[00:36:21] components but also whenever discount
[00:36:23] variable changes so initially it's going
[00:36:25] to set this to zero plus one right which
[00:36:27] means that count will change count will
[00:36:29] be one count has changed so now we're
[00:36:31] going to recreate this function and
[00:36:33] count will be one one plus one is two
[00:36:35] right so then it should work so let's
[00:36:37] save here and see what we get I'm going
[00:36:38] to refresh for clean slate so now we can
[00:36:40] see 0 1 2 3 or and it was a weird Hiccup
[00:36:44] and there we have some more hiccups and
[00:36:46] now it's getting really strange and now
[00:36:48] we get a really strange result here
[00:36:50] where it's sort of passing out this
[00:36:52] simply doesn't work and the reason is
[00:36:54] that we are not canceling the previous
[00:36:56] intervals right so now whenever account
[00:36:58] changes we're simply adding another
[00:37:00] interval right so now every one second
[00:37:03] we're just adding another intervals this
[00:37:05] is going to go completely wrong yeah so
[00:37:07] you can see it's completely out of whack
[00:37:08] now so what we need to do is not only
[00:37:10] create a new interfall we also need to
[00:37:12] cancel the previous one so set interfall
[00:37:14] actually returns an identifier we can
[00:37:16] call it identifier which is I and we can
[00:37:18] use that to cancel this one so we use
[00:37:20] effects also has a so-called cleanup
[00:37:22] function so you can return a function
[00:37:25] here and this function will run when you
[00:37:27] unmount the component well that's not
[00:37:29] the case here but it also runs before
[00:37:31] running the next use effect call so
[00:37:33] basically you can clean up something
[00:37:35] from the previous use effect run so what
[00:37:37] we can do here is we can cancel that
[00:37:40] interval from the previous run we can
[00:37:42] call clear interfall and we pass the
[00:37:44] identifier like this if I save here and
[00:37:47] we go back refresh now let's see if we
[00:37:49] get a normal result which we want two
[00:37:51] three four five six and this seems to
[00:37:53] work right we don't get any strange
[00:37:55] effects here right so this looks very
[00:37:57] tricky we have this inner functions so
[00:37:59] it's really important that you have
[00:38:00] mastered the JavaScript fundamentals
[00:38:02] right so I see a lot of people jump into
[00:38:03] reacts with a lot of enthusiasm but make
[00:38:05] sure you've mastered like JavaScript and
[00:38:07] also CSS now there is actually a cleaner
[00:38:09] solution than this so we don't need to
[00:38:10] do all of this so let me remove this we
[00:38:12] can remove all of this again also on
[00:38:14] this so we can actually just create this
[00:38:16] function once it will work but we have
[00:38:19] to do the set function a little bit
[00:38:20] differently here so here we need to
[00:38:22] depend on the previous value right so
[00:38:24] what we can also do is simply do this so
[00:38:26] whatever the previous value is just
[00:38:28] increment that by one right and this
[00:38:30] will always be the most up-to-date value
[00:38:32] that we can get for setting state so if
[00:38:34] we try this and then our refresh here
[00:38:36] let's see if this works so now we create
[00:38:37] this function once and now you can see
[00:38:39] it is properly updating the count on the
[00:38:42] page all right number one has to do with
[00:38:44] fetching and use effects we saw it
[00:38:46] before but let's talk a little bit more
[00:38:47] about why you shouldn't do that in the
[00:38:49] real world so as an example I have a
[00:38:51] simple post component here and it's just
[00:38:53] showing us a button and it's keeping
[00:38:55] track of an ID and currently it's set to
[00:38:57] 1 and then it's also render during this
[00:38:59] post body component so I have another
[00:39:00] component here where it's using new
[00:39:02] state for text and it's going to Output
[00:39:04] that text and then we have a use effect
[00:39:06] here which is currently empty so we have
[00:39:08] two components here in one file that's
[00:39:10] perfectly fine and what we want to do
[00:39:11] here is this ID we want to pass that to
[00:39:13] the post body and based on that ID the
[00:39:16] post body will fetch some post let's
[00:39:19] pass the ID to post body here so we can
[00:39:21] do ID as ID and we get a touchscreen
[00:39:24] problem right so typescript is helping
[00:39:26] us out it's telling us that this
[00:39:27] component right now is not accepting an
[00:39:29] ID prop and it's true so let's actually
[00:39:31] accept an ID prop and don't worry you
[00:39:33] don't need no time script for this but
[00:39:35] if you have props for a component you
[00:39:37] you do want to type this usually so we
[00:39:39] can do that in line so we could do ID
[00:39:41] it's going to be number but I always
[00:39:43] think that this looks a bit clumsy I
[00:39:45] like to extract this into its own
[00:39:46] separate type post body props and let me
[00:39:49] Define that up here so type post body
[00:39:52] props it's going to be an object with an
[00:39:55] ID that's going to be a number so that's
[00:39:57] the ID and and based on that ID we want
[00:40:00] to fetch a post and display it here
[00:40:02] right so Junior developers do this is
[00:40:04] quite typical is when you mount a
[00:40:05] component you want to fetch some data
[00:40:07] and this is the fetch call that we want
[00:40:09] to make we're going to make a fetch call
[00:40:10] to some dummy API based on the ID so
[00:40:13] initially ID is one right so it's going
[00:40:15] to be post one we get some response
[00:40:16] we're going to parse that as Json
[00:40:18] meaning we're going to get Json as a
[00:40:20] response and convert that to a normal
[00:40:21] JavaScript objects and that's what we
[00:40:23] get here and then we can just set the
[00:40:25] text that we actually want to display
[00:40:27] eventually right so bear with me here so
[00:40:29] what we're going to do is whenever we
[00:40:30] click this button we want to be able to
[00:40:32] change the ID and then it's going to
[00:40:34] fetch a new post right so here show me a
[00:40:36] different post so let's do that now
[00:40:37] right so when I say here what happens is
[00:40:39] this post body will be mounted right so
[00:40:42] it's going to run once because this
[00:40:44] dependency array is empty so it's going
[00:40:45] to run once on mounting it's going to
[00:40:47] fetch that based on the ID the ID right
[00:40:49] now is one right so we get some post
[00:40:51] here post text okay so now we want to
[00:40:53] click on this button and it should
[00:40:55] change the ID so on click I could call
[00:40:57] it handle click can Define that up here
[00:40:59] but this time I'll do it in line here so
[00:41:01] here we want to set the ID but not to
[00:41:03] some fixed number like this it should be
[00:41:05] a random number so in JavaScript you can
[00:41:07] say math.random to get a random number
[00:41:09] between 0 and 1 and we want to do that
[00:41:12] times 100 so we get a random number
[00:41:14] between 0 and 100 and this can contain
[00:41:17] decimals so we're going to round it up
[00:41:19] or down doesn't really matter you can do
[00:41:21] math plus floor to round it down so that
[00:41:23] we don't have any decimals so 4.5 will
[00:41:25] become 4 3.2 becomes 3. right so that's
[00:41:28] not really important the idea here is
[00:41:30] that we're just changing the ID to some
[00:41:32] random number so now I'm going to click
[00:41:34] here and what should happen is that it
[00:41:36] should fetch a new post so if I click
[00:41:38] here let's see it doesn't work because
[00:41:40] right now the way that we've done this
[00:41:42] is user fact this will only run when the
[00:41:44] component first mounts because it's an
[00:41:46] empty dependency array so here if the ID
[00:41:48] changes transfer here if the ID becomes
[00:41:51] 10 let's say ID becomes 10. this
[00:41:53] component will re-render but this use
[00:41:54] effect will not run again because it
[00:41:56] only run when it's mounted we can add ID
[00:41:58] here so now it will run both when it's
[00:42:01] mounted but also every time the ID
[00:42:03] changes so now if I save here now if I
[00:42:05] click here you can see every time we get
[00:42:08] a new post that takes a second or so so
[00:42:10] I click now and you can see it takes a
[00:42:12] second or so before we actually get the
[00:42:14] post alright so so far so good all of
[00:42:16] this is fine if you're just testing
[00:42:18] something or you're building some very
[00:42:19] small app now in the real world though
[00:42:21] if we want to make it more professional
[00:42:22] we need to think about the edge cases as
[00:42:25] well for example what if I click
[00:42:26] multiple times quickly after another
[00:42:28] here you can see when I click multiple
[00:42:29] times it sort of goes through then
[00:42:32] flashes through them if I click three
[00:42:34] times here you can see it flashes
[00:42:36] through them if I click five times here
[00:42:38] it flashes through all of them because
[00:42:40] what happens is every time you click the
[00:42:42] ID gets changed and it's going to fire a
[00:42:45] fetch call so if you click five times
[00:42:46] and so we're gonna get five times so
[00:42:48] it's gonna make this fat call for all of
[00:42:50] them eventually they get some data and
[00:42:52] they're gonna try to set the text so
[00:42:54] you're gonna get five set text very
[00:42:56] quickly one after another and that's not
[00:42:57] really the UI experience that we would
[00:42:59] expect here if you click multiple times
[00:43:01] after another we don't want to flash
[00:43:03] through them we only want to see the
[00:43:06] last click basically the last one so we
[00:43:08] basically want to cancel previous fetch
[00:43:10] calls this is the real world right so if
[00:43:12] you want to become a professional
[00:43:13] developer these are the things that
[00:43:14] you're going to have to think about and
[00:43:15] solve so browsers do give us the option
[00:43:17] to do this ourselves so what you can
[00:43:19] have is a so-called new abort controller
[00:43:22] so you have a new abort controller and
[00:43:25] you can pass a second argument here to
[00:43:27] fetch it's going to be an object and you
[00:43:29] can pass a signal here and that's coming
[00:43:31] from the controller so controller.signal
[00:43:33] so basically we're attaching some signal
[00:43:35] to this Fetch and then we can use that
[00:43:37] to cancel it so user thanks also has a
[00:43:40] cleanup function this function runs
[00:43:41] whenever you unmount the components
[00:43:43] which will not happen here but it also
[00:43:45] runs before you go for another round of
[00:43:48] the use effect so it allows you to clean
[00:43:50] up some stuff from the previous run and
[00:43:52] that's what we can use here so what we
[00:43:53] can do here I don't have to go in here I
[00:43:55] can also just write it like this I can
[00:43:56] use that controller Dot abort so now
[00:43:59] every time this ID changes and we're
[00:44:01] going to run this user effect again
[00:44:03] right before we do that we're first
[00:44:05] going to run this cleanup function which
[00:44:07] allows us to abort the previous fetch
[00:44:09] call looks very clumsy as you can see
[00:44:11] but now when I do this and I click
[00:44:12] multiple times you can see when I stop
[00:44:14] clicking it will just show me the last
[00:44:16] one it doesn't flash through them so if
[00:44:18] I click twice it's only going to show
[00:44:19] one if I click three times it's only
[00:44:21] going to show one right so what we saw
[00:44:23] here if I remove all of this what we see
[00:44:25] here is basically sort of a race
[00:44:27] condition where the different fetches
[00:44:28] are basically racing against each other
[00:44:30] to see which one will set the text first
[00:44:32] or last and that's one problem that
[00:44:34] you're going to have with fetching and
[00:44:36] use effects but there are other problems
[00:44:37] as well like caching for example what if
[00:44:39] the ID is the same as one that you
[00:44:41] already fetched before you're gonna make
[00:44:43] another fetch call necessarily you could
[00:44:45] cache that and you can reuse the
[00:44:47] previous result and if you had some kind
[00:44:48] of caching solution we cannot do that
[00:44:50] like this here also it only fetches I
[00:44:52] have the rendering first we're going to
[00:44:54] run all of this I'm just gonna render
[00:44:55] this and then it's gonna fire use
[00:44:57] effects which will then change the text
[00:44:59] here and it's going to render again
[00:45:00] right so it's basic it's quite late
[00:45:01] basically before it can start fetching
[00:45:03] also what if you want to do some loading
[00:45:05] State we would have to create a new
[00:45:07] variable here loading set loading and
[00:45:09] then sort of undo that here set loading
[00:45:11] to files if you have an error with
[00:45:13] fetching you would have an error State
[00:45:15] and you know you have to keep track of
[00:45:17] that so if you shouldn't do it in use
[00:45:18] effect then how should you fetch data
[00:45:20] well these days in next.js you should
[00:45:22] try fetching data in server component so
[00:45:25] highly recommend you check out my react
[00:45:27] next.js course in which we talk about
[00:45:28] that and if you want to fetch data on
[00:45:30] the clients and clients components there
[00:45:33] are libraries like react query or SWR by
[00:45:36] for cell next to us that will take care
[00:45:38] of a lot of those issues like caching
[00:45:40] race conditions loading States error
[00:45:42] States and many other things that you
[00:45:44] will run into in the real world when you
[00:45:45] start fetching data right so I highly
[00:45:47] recommend you check out my react next to
[00:45:49] S course to really become a professional
[00:45:51] react next to S developer well done for
[00:45:53] making it this far this wasn't easy the
[00:45:54] version tricky things it's okay if
[00:45:56] you're a little bit confused but I hope
[00:45:57] that you learned a thing or two all of
[00:45:59] this is going to be very easy if you've
[00:46:00] picked up the fundamentals so make sure
[00:46:02] you master react and react is very easy
[00:46:04] to master if you have already mastered
[00:46:06] JavaScript and also make sure that you
[00:46:08] learn CSS properly I have courses and
[00:46:09] all of that check out the links in the
[00:46:11] description hope that you learned a
[00:46:12] thing or two thanks for watching and I
[00:46:14] hope to see you soon bye
